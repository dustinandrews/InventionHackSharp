<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Inv.Platform</name>
    </assembly>
    <members>
        <member name="T:Inv.Animation">
            <summary>
            Animations are used to manipulate the elements of a panel to achieve visual effects.
            </summary>
        </member>
        <member name="M:Inv.Animation.New">
            <summary>
            Create new animation.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Animation.IsActive">
            <summary>
            Ask if the animation has been started but not yet stopped.
            </summary>
        </member>
        <member name="P:Inv.Animation.IsCompleted">
            <summary>
            Ask if the animation has run to completion.
            </summary>
        </member>
        <member name="E:Inv.Animation.CommenceEvent">
            <summary>
            Fired when the animation begins.
            </summary>
        </member>
        <member name="E:Inv.Animation.CompleteEvent">
            <summary>
            Fired when the animation ends.
            </summary>
        </member>
        <member name="M:Inv.Animation.RemoveTargets">
            <summary>
            Remove all targets.
            </summary>
        </member>
        <member name="M:Inv.Animation.AddTarget(Inv.Panel)">
            <summary>
            Add a new animation target.
            </summary>
            <param name="Panel"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Animation.Restart">
            <summary>
            Restart the animation.
            </summary>
        </member>
        <member name="M:Inv.Animation.Start">
            <summary>
            Start the animation.
            </summary>
        </member>
        <member name="M:Inv.Animation.Stop">
            <summary>
            Stop the animation.
            </summary>
        </member>
        <member name="T:Inv.AnimationTarget">
            <summary>
            Selects a panel for adding animation transforms.
            </summary>
        </member>
        <member name="M:Inv.AnimationTarget.FadeOpacityOut(System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Fade the panel to opacity 0.0F.
            </summary>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.FadeOpacityIn(System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Fade the panel to opacity 1.0F.
            </summary>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.FadeOpacity(System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Fade the panel from the current opacity to the new opacity.
            </summary>
            <param name="ToOpacity"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.FadeOpacity(System.Single,System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Fade the panel to from opacity <paramref name="FromOpacity"/> to opacity <paramref name="ToOpacity"/>.
            </summary>
            <param name="FromOpacity">Inital opacity</param>
            <param name="ToOpacity">Final opacity</param>
            <param name="Duration">The time to animate from the initial opacity to the final opacity.</param>
            <param name="Offset">Optionally delay the start time of the animation.</param>
        </member>
        <member name="M:Inv.AnimationTarget.ScaleWidth(System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Scale the width of the panel to a percentage of the full width.
            </summary>
            <param name="ToWidth"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.ScaleWidth(System.Single,System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Scale the width of the panel from and to a percentage of the full width.
            </summary>
            <param name="FromWidth"></param>
            <param name="ToWidth"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.ScaleHeight(System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Scale the height of the panel from and to a percentage of the full height.
            </summary>
            <param name="ToHeight"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.ScaleHeight(System.Single,System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Scale the height of the panel from and to a percentage of the full height.
            </summary>
            <param name="FromHeight"></param>
            <param name="ToHeight"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.ScaleSize(System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Scale the size of the panel to a percentage of the full size (both width and height).
            </summary>
            <param name="ToSize"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.ScaleSize(System.Single,System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Scale the size of the panel from and to a percentage of the full size (both width and height).
            </summary>
            <param name="FromSize"></param>
            <param name="ToSize"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.ScaleSize(System.Single,System.Single,System.Single,System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Scale the size of the panel from and to a percentage of the full size (with different scaling values for width and height).
            </summary>
            <param name="FromWidth"></param>
            <param name="ToWidth"></param>
            <param name="FromHeight"></param>
            <param name="ToHeight"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.RotateAngle(System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Rotate the panel from the current angle to a new angle.
            </summary>
            <param name="ToAngle">To angle in degrees</param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.RotateAngle(System.Single,System.Single,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Rotate the panel from a specified angle to a new angle.
            </summary>
            <param name="FromAngle">From angle in degrees</param>
            <param name="ToAngle">To angle in degrees</param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.TranslateX(System.Int32,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Translate the panel to a new X offset.
            </summary>
            <param name="ToXOffset"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.TranslateX(System.Int32,System.Int32,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Translate the panel from a specified X offset to a new X offset.
            </summary>
            <param name="FromXOffset"></param>
            <param name="ToXOffset"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.TranslateY(System.Int32,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Translate the panel from the current Y offset to a new Y offset.
            </summary>
            <param name="ToYOffset"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.TranslateY(System.Int32,System.Int32,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Translate the panel from a specified Y offset to a new Y offset.
            </summary>
            <param name="FromYOffset"></param>
            <param name="ToYOffset"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.TranslatePosition(System.Int32,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Translate the panel from the current XY offset to a new XY offset.
            </summary>
            <param name="ToOffset"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.TranslatePosition(System.Int32,System.Int32,System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Translate the panel from a specified XY offset to a new XY offset.
            </summary>
            <param name="FromOffset"></param>
            <param name="ToOffset"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="M:Inv.AnimationTarget.TranslatePosition(System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Nullable{System.Int32},System.TimeSpan,System.Nullable{System.TimeSpan})">
            <summary>
            Translate the panel from a specified X and Y offset to a new X and Y offset.
            </summary>
            <param name="FromXOffset"></param>
            <param name="ToXOffset"></param>
            <param name="FromYOffset"></param>
            <param name="ToYOffset"></param>
            <param name="Duration"></param>
            <param name="Offset"></param>
        </member>
        <member name="T:Inv.Audio">
            <summary>
            See <see cref="P:Inv.Application.Audio"/>
            </summary>
        </member>
        <member name="M:Inv.Audio.SetMuted(System.Boolean)">
            <summary>
            Global mute for sounds played through this API.
            </summary>
            <param name="IsMuted"></param>
        </member>
        <member name="M:Inv.Audio.SetRateControl(System.Boolean)">
            <summary>
            Global control to prevent rate variations for sounds played through this API.
            </summary>
            <param name="IsRateControlled"></param>
        </member>
        <member name="M:Inv.Audio.SetVolumeControl(System.Boolean)">
            <summary>
            Global control to prevent volume variations for sounds played through this API.
            </summary>
            <param name="IsVolumeControlled"></param>
        </member>
        <member name="M:Inv.Audio.SetPanControl(System.Boolean)">
            <summary>
            Global control to prevent pan variations for sounds played through this API.
            </summary>
            <param name="IsPanControlled"></param>
        </member>
        <member name="M:Inv.Audio.Play(Inv.Sound,System.Single,System.Single,System.Single)">
            <summary>
            Play a mp3 track using the platform's audio subsystem.
            The sound will be played once and to the end of the track.
            </summary>
            <param name="Sound">The mp3 track held in memory</param>
            <param name="Volume">The volume adjustment between 0.0 and 1.0</param>
            <param name="Rate">The rate variation between 0.5 and 2.0</param>
            <param name="Pan">The balance of left and right speakers between -1.0 and 1.0</param>
        </member>
        <member name="M:Inv.Audio.NewClip(Inv.Sound,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Create a clip which can be played and optionally stopped before it is finished.
            </summary>
            <param name="Sound">The mp3 track held in memory</param>
            <param name="Volume">The volume adjustment between 0.0 and 1.0</param>
            <param name="Rate">The rate variation between 0.5 and 2.0</param>
            <param name="Pan">The balance of left and right speakers between -1.0 and 1.0</param>
            <param name="Loop">Loop the playing of this sound until it is explicitly stopped</param>
            <returns></returns>
        </member>
        <member name="M:Inv.Audio.GetLength(Inv.Sound)">
            <summary>
            Get the play duration of the sound as a TimeSpan (to the millisecond accuracy).
            </summary>
            <param name="Sound"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.AudioClip">
            <summary>
            Control the playback of a sound track.
            </summary>
        </member>
        <member name="P:Inv.AudioClip.Sound">
            <summary>
            The sound to be played.
            </summary>
        </member>
        <member name="P:Inv.AudioClip.Volume">
            <summary>
            The volume to play the sound between 0.0F and 1.0F.
            </summary>
        </member>
        <member name="P:Inv.AudioClip.Pan">
            <summary>
            The rate to play the sound between 0.5F and 2.0F.
            </summary>
        </member>
        <member name="P:Inv.AudioClip.Rate">
            <summary>
            The pan to play the sound between -1.0F and +1.0F.
            -1 is entirely the left speaker.
            +1 is entirely the right speaker.
            </summary>
        </member>
        <member name="P:Inv.AudioClip.Loop">
            <summary>
            Whether to continuously loop the track until it is manually stopped.
            </summary>
        </member>
        <member name="M:Inv.AudioClip.Play">
            <summary>
            Play the sound.
            </summary>
        </member>
        <member name="M:Inv.AudioClip.Stop">
            <summary>
            Stop playing the sound.
            </summary>
        </member>
        <member name="T:Inv.Calendar">
            <summary>
            See <see cref="P:Inv.Application.Calendar"/>
            </summary>
        </member>
        <member name="M:Inv.Calendar.GetTimeZoneName">
            <summary>
            Get the time zone name configured on this device.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Calendar.NewDateTimePicker">
            <summary>
            Create a date and time picker using the device platform controls.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Calendar.NewDatePicker">
            <summary>
            Create a date picker using the device platform controls.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Calendar.NewTimePicker">
            <summary>
            Create a time picker using the device platform controls.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.CalendarPicker">
            <summary>
            Request the user to pick a date and/or time.
            </summary>
        </member>
        <member name="M:Inv.CalendarPicker.NewDateTime">
            <summary>
            New date time picker.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.CalendarPicker.NewDate">
            <summary>
            New date picker.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.CalendarPicker.NewTime">
            <summary>
            New time picker.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.CalendarPicker.SetDate">
            <summary>
            If the user will be asked for a date.
            </summary>
        </member>
        <member name="P:Inv.CalendarPicker.SetTime">
            <summary>
            If the user will be asked for a time.
            </summary>
        </member>
        <member name="P:Inv.CalendarPicker.Value">
            <summary>
            The initial value and the value that was picked.
            </summary>
        </member>
        <member name="E:Inv.CalendarPicker.SelectEvent">
            <summary>
            Fired when the user picks a date and/or time.
            </summary>
        </member>
        <member name="E:Inv.CalendarPicker.CancelEvent">
            <summary>
            Fired when the user cancels this picker.
            </summary>
        </member>
        <member name="M:Inv.CalendarPicker.Show">
            <summary>
            Show the picker and ask the user to select a date and/or time.
            </summary>
        </member>
        <member name="T:Inv.Clipboard">
            <summary>
            See <see cref="P:Inv.Application.Clipboard"/>
            </summary>
        </member>
        <member name="P:Inv.Clipboard.Text">
            <summary>
            Read and write unicode text from the shared clipboard.
            </summary>
        </member>
        <member name="P:Inv.ControllerTrigger.Type">
            <summary>
            Left or Right trigger.
            </summary>
        </member>
        <member name="P:Inv.ControllerTrigger.Depression">
            <summary>
            The position of the trigger.
            The value is between 0.0 (not depressed) and 1.0 (fully depressed).
            </summary>
        </member>
        <member name="P:Inv.ControllerThumbstick.X">
            <summary>
            The position of the thumbstick on the X-axis.
            The value is between -1.0 and 1.0.
            </summary>
        </member>
        <member name="P:Inv.ControllerThumbstick.Y">
            <summary>
            The position of the thumbstick on the Y-axis.
            The value is between -1.0 and 1.0.
            </summary>
        </member>
        <member name="P:Inv.ControllerThumbstick.Button">
            <summary>
            The thumbstick is a button itself.
            </summary>
        </member>
        <member name="T:Inv.Device">
            <summary>
            See <see cref="P:Inv.Application.Device"/>.
            </summary>
        </member>
        <member name="P:Inv.Device.Target">
            <summary>
            Target platform: Android, iOS, Windows Desktop and Universal Windows.
            </summary>
        </member>
        <member name="P:Inv.Device.IsMobile">
            <summary>
            Is this a mobile device platform.
            </summary>
        </member>
        <member name="P:Inv.Device.IsWindows">
            <summary>
            Is this a Windows platform.
            </summary>
        </member>
        <member name="P:Inv.Device.IsWindowsDesktop">
            <summary>
            Is this a Windows Desktop (PC) platform.
            </summary>
        </member>
        <member name="P:Inv.Device.IsUniversalWindows">
            <summary>
            Is this a Windows Desktop (PC) platform.
            </summary>
        </member>
        <member name="P:Inv.Device.IsAndroid">
            <summary>
            Is this a Android platform.
            </summary>
        </member>
        <member name="P:Inv.Device.IsIOS">
            <summary>
            Is this an iOS platform.
            </summary>
        </member>
        <member name="P:Inv.Device.Name">
            <summary>
            Name of the device.
            </summary>
        </member>
        <member name="P:Inv.Device.Manufacturer">
            <summary>
            Manufacturer of the device.
            </summary>
        </member>
        <member name="P:Inv.Device.Model">
            <summary>
            Model of the device.
            </summary>
        </member>
        <member name="P:Inv.Device.System">
            <summary>
            Operating system running the device.
            </summary>
        </member>
        <member name="P:Inv.Device.Keyboard">
            <summary>
            Does the device have a physical keyboard.
            </summary>
        </member>
        <member name="P:Inv.Device.Mouse">
            <summary>
            Does the device have a mouse.
            </summary>
        </member>
        <member name="P:Inv.Device.Touch">
            <summary>
            Does the device have a touch screen.
            </summary>
        </member>
        <member name="P:Inv.Device.ProportionalFontName">
            <summary>
            The platform-specific default proportional font name.
            </summary>
        </member>
        <member name="P:Inv.Device.MonospacedFontName">
            <summary>
            The platform-specific default monospaced font name.
            </summary>
        </member>
        <member name="P:Inv.Device.PixelDensity">
            <summary>
            Pixel density of the device screen.
            eg. 2.0F means 2px to a 1pt
            </summary>
        </member>
        <member name="P:Inv.Device.Theme">
            <summary>
            Default theme for this device: Light or Dark.
            </summary>
        </member>
        <member name="T:Inv.DeviceTheme">
            <summary>
            The setting of the device's default theme colours (light or dark)
            </summary>
        </member>
        <member name="F:Inv.DeviceTheme.Light">
            <summary>
            Light background and dark text colours.
            </summary>
        </member>
        <member name="F:Inv.DeviceTheme.Dark">
            <summary>
            Dark background and light text colours;
            </summary>
        </member>
        <member name="T:Inv.DeviceTarget">
            <summary>
            Enumeration of device platforms.
            </summary>
        </member>
        <member name="F:Inv.DeviceTarget.Android">
            <summary>
            Android
            </summary>
        </member>
        <member name="F:Inv.DeviceTarget.IOS">
            <summary>
            iOS
            </summary>
        </member>
        <member name="F:Inv.DeviceTarget.UniversalWindows">
            <summary>
            Universal Windows
            </summary>
        </member>
        <member name="F:Inv.DeviceTarget.WindowsDesktop">
            <summary>
            Windows Desktop
            </summary>
        </member>
        <member name="T:Inv.Directory">
            <summary>
            See <see cref="P:Inv.Application.Directory"/>.
            </summary>
        </member>
        <member name="P:Inv.Directory.Installation">
            <summary>
            Platform-specific installation location.
            </summary>
        </member>
        <member name="P:Inv.Directory.Root">
            <summary>
            Root folder for the installation.
            </summary>
        </member>
        <member name="M:Inv.Directory.NewFolder(System.String)">
            <summary>
            Select a folder in the root folder.
            </summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Directory.NewAsset(System.String)">
            <summary>
            Select an asset from the installation files.
            </summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Directory.NewAnyFilePicker">
            <summary>
            Request the user to pick any file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Directory.NewImageFilePicker">
            <summary>
            Request the user to pick an image file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Directory.NewSoundFilePicker">
            <summary>
            Request the user to pick a sound file.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.Pick">
            <summary>
            File that has been picked by the user.
            </summary>
        </member>
        <member name="P:Inv.Pick.Name">
            <summary>
            Name of the picked file, including the extension.
            </summary>
        </member>
        <member name="P:Inv.Pick.Title">
            <summary>
            Name of the picked file, excluding the extension.
            </summary>
        </member>
        <member name="P:Inv.Pick.Extension">
            <summary>
            Extension of the picked file.
            </summary>
        </member>
        <member name="M:Inv.Pick.Open">
            <summary>
            Open a read stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Pick.ReadBinary">
            <summary>
            Read the entire picked file into a binary.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Pick.AsText">
            <summary>
            Treat the pick file as text.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Pick.AsCsv">
            <summary>
            Treat the pick file as csv.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Pick.AsIni">
            <summary>
            Treat the pick file as ini.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Pick.AsCompact">
            <summary>
            Treat the pick file as compact (custom structured binary).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Pick.AsSyntax(Inv.Syntax.Grammar)">
            <summary>
            Treat the pick file as syntax (custom structured text).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.TextPick">
            <summary>
            Text API for a picked file.
            </summary>
        </member>
        <member name="M:Inv.TextPick.Open">
            <summary>
            Open the picked file with <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextPick.ReadLines">
            <summary>
            Read all lines from the picked file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextPick.ReadAll">
            <summary>
            Read the entire picked file into a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.CsvPick">
            <summary>
            Csv API for a picked file.
            </summary>
        </member>
        <member name="M:Inv.CsvPick.Open">
            <summary>
            Open the picked file with <see cref="T:Inv.CsvReader"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.IniPick">
            <summary>
            Ini API for a picked file.
            </summary>
        </member>
        <member name="M:Inv.IniPick.Open">
            <summary>
            Open the picked file with <see cref="T:Inv.IniReader"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.CompactPick">
            <summary>
            Compact API for a picked file.
            </summary>
        </member>
        <member name="M:Inv.CompactPick.Open">
            <summary>
            Open the picked file with <see cref="T:Inv.CompactReader"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.SyntaxPick">
            <summary>
            Syntax API for a picked file.
            </summary>
        </member>
        <member name="M:Inv.SyntaxPick.Read(System.Action{Inv.Syntax.Reader})">
            <summary>
            Read the picked file as structured syntax.
            </summary>
            <param name="ExtractAction"></param>
        </member>
        <member name="T:Inv.DirectoryFilePicker">
            <summary>
            Base file picker.
            </summary>
        </member>
        <member name="P:Inv.DirectoryFilePicker.Title">
            <summary>
            Title to display to the user.
            </summary>
        </member>
        <member name="E:Inv.DirectoryFilePicker.SelectEvent">
            <summary>
            Fired when the user selects a pick.
            </summary>
        </member>
        <member name="E:Inv.DirectoryFilePicker.CancelEvent">
            <summary>
            Fired when the user cancels the pick.
            </summary>
        </member>
        <member name="M:Inv.DirectoryFilePicker.Show">
            <summary>
            Show the file picker to the user.
            </summary>
        </member>
        <member name="T:Inv.DirectoryImagePicker">
            <summary>
            Image file picker.
            </summary>
        </member>
        <member name="P:Inv.DirectoryImagePicker.Title">
            <summary>
            Title to display to the user.
            </summary>
        </member>
        <member name="E:Inv.DirectoryImagePicker.SelectEvent">
            <summary>
            Fired when the user picks an image.
            </summary>
        </member>
        <member name="E:Inv.DirectoryImagePicker.CancelEvent">
            <summary>
            Fired when the user cancels the pick.
            </summary>
        </member>
        <member name="M:Inv.DirectoryImagePicker.Show">
            <summary>
            Show the image picker to the user.
            </summary>
        </member>
        <member name="T:Inv.DirectorySoundPicker">
            <summary>
            Sound file picker.
            </summary>
        </member>
        <member name="P:Inv.DirectorySoundPicker.Title">
            <summary>
            Title to display to the user.
            </summary>
        </member>
        <member name="E:Inv.DirectorySoundPicker.SelectEvent">
            <summary>
            Fired when the user picks a sound file.
            </summary>
        </member>
        <member name="E:Inv.DirectorySoundPicker.CancelEvent">
            <summary>
            Fired when the user cancels the pick.
            </summary>
        </member>
        <member name="M:Inv.DirectorySoundPicker.Show">
            <summary>
            Show the sound picker to the user.
            </summary>
        </member>
        <member name="T:Inv.Folder">
            <summary>
            Represents a folder inside the installation root folder.
            </summary>
        </member>
        <member name="P:Inv.Folder.Parent">
            <summary>
            The parent folder of this folder.
            </summary>
        </member>
        <member name="P:Inv.Folder.Name">
            <summary>
            Name of the folder.
            </summary>
        </member>
        <member name="M:Inv.Folder.NewFile(System.String)">
            <summary>
            Select a file in the folder.
            </summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Folder.NewFolder(System.String)">
            <summary>
            Select a subfolder.
            </summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Folder.GetFiles(System.String)">
            <summary>
            Enumerate the files in the folder matching the <paramref name="Mask"/>.
            </summary>
            <param name="Mask"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Folder.GetFolders(System.String)">
            <summary>
            Enumerate the subfolders matching the <paramref name="Mask"/>.
            </summary>
            <param name="Mask"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Folder.GetRelativePath">
            <summary>
            Relative path of the folder to the installation root.
            </summary>
        </member>
        <member name="M:Inv.Folder.GetPlatformPath">
            <summary>
            Returns the fully qualified and platform-specific file path.
            Note that this is a leaky abstraction to the underlying platform implementation.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.Asset">
            <summary>
            Assets are additional files in the application folder.
            These files are delivered by the app developer.
            </summary>
        </member>
        <member name="P:Inv.Asset.Directory">
            <summary>
            Owning directory API.
            </summary>
        </member>
        <member name="P:Inv.Asset.Name">
            <summary>
            Name of the asset, including the extension. eg. "Notes.txt".
            </summary>
        </member>
        <member name="P:Inv.Asset.Title">
            <summary>
            Name of the asset, exclusing the extension. eg. "Notes".
            </summary>
        </member>
        <member name="P:Inv.Asset.Extension">
            <summary>
            Extension of the asset. eg. ".txt".
            </summary>
        </member>
        <member name="M:Inv.Asset.Exists">
            <summary>
            Ask if the asset exists in the application folder.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Asset.Open">
            <summary>
            Open the asset as a stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Asset.AsText">
            <summary>
            Treat this asset as Text.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Asset.AsCsv">
            <summary>
            Treat this asset as Csv.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Asset.AsIni">
            <summary>
            Treat this asset as Ini.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Asset.AsCompact">
            <summary>
            Treat this asset as Compact (custom structured binary).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Asset.AsSyntax(Inv.Syntax.Grammar)">
            <summary>
            Treat this asset as Syntax (custom structured text).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Asset.Copy(Inv.File)">
            <summary>
            Copy the asset to a file.
            </summary>
            <param name="File"></param>
        </member>
        <member name="T:Inv.TextAsset">
            <summary>
            Text Asset API.
            </summary>
        </member>
        <member name="M:Inv.TextAsset.Open">
            <summary>
            Open the asset with <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextAsset.ReadLines">
            <summary>
            Read all the text lines from the asset.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextAsset.ReadAll">
            <summary>
            Read the entire text asset into a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.CsvAsset">
            <summary>
            Csv Asset API.
            </summary>
        </member>
        <member name="M:Inv.CsvAsset.Open">
            <summary>
            Open the asset with <see cref="T:Inv.CsvReader"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.IniAsset">
            <summary>
            Ini Asset API.
            </summary>
        </member>
        <member name="M:Inv.IniAsset.Open">
            <summary>
            Open the asset with <see cref="T:Inv.IniReader"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.CompactAsset">
            <summary>
            Compact Asset API.
            </summary>
        </member>
        <member name="M:Inv.CompactAsset.Open">
            <summary>
            Open the asset with <see cref="T:Inv.CompactReader"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.SyntaxAsset">
            <summary>
            Syntax Asset API.
            </summary>
        </member>
        <member name="M:Inv.SyntaxAsset.Read(System.Action{Inv.Syntax.Reader})">
            <summary>
            Read the asset as structured text syntax.
            </summary>
            <param name="ExtractAction"></param>
        </member>
        <member name="T:Inv.File">
            <summary>
            Represents a file in the application folder.
            </summary>
        </member>
        <member name="P:Inv.File.Folder">
            <summary>
            Owning folder.
            </summary>
        </member>
        <member name="P:Inv.File.Name">
            <summary>
            Name of the file, including the extension. eg. "Notes.txt"
            </summary>
        </member>
        <member name="P:Inv.File.Title">
            <summary>
            Name of the file, excluding the extension. eg. "Notes"
            </summary>
        </member>
        <member name="P:Inv.File.Extension">
            <summary>
            Extension of the file. eg. ".txt"
            </summary>
        </member>
        <member name="M:Inv.File.GetSize">
            <summary>
            Get the length of the file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.GetLastWriteTimeUtc">
            <summary>
            Get the last write time (Utc) for the file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.SetLastWriteTimeUtc(System.DateTime)">
            <summary>
            Set the last write time (Utc) for the file.
            </summary>
            <param name="Timestamp"></param>
        </member>
        <member name="M:Inv.File.Create">
            <summary>
            Create new or replace an existing file and return the stream for writing.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.Open">
            <summary>
            Open an existing file and return the stream for reading.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.Append">
            <summary>
            Append an existing file and return the stream for writing, positioned at the end of the file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.Exists">
            <summary>
            Ask if the file exists in the owning folder.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.Delete">
            <summary>
            Delete the file from the owning folder.
            </summary>
        </member>
        <member name="M:Inv.File.Copy(Inv.File)">
            <summary>
            Copy this file to the location specified by <paramref name="CopyFile"/> but fail if it already exists.
            </summary>
            <param name="CopyFile"></param>
        </member>
        <member name="M:Inv.File.CopyReplace(Inv.File)">
            <summary>
            Copy this file to the location specified by <paramref name="CopyFile"/> and overwrite if it already exists.
            </summary>
            <param name="CopyFile"></param>
        </member>
        <member name="M:Inv.File.Move(Inv.File)">
            <summary>
            Move this file to the location specified by <paramref name="MoveFile"/> but fail if it already exists.
            </summary>
            <param name="MoveFile"></param>
        </member>
        <member name="M:Inv.File.MoveReplace(Inv.File)">
            <summary>
            Move this file to the location specified by <paramref name="MoveFile"/> and overwrite if it already exists.
            </summary>
            <param name="MoveFile"></param>
        </member>
        <member name="M:Inv.File.ReadAllBytes">
            <summary>
            Read the entire file into a byte array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.WriteAllBytes(System.Byte[])">
            <summary>
            Create or replace the entire file with the byte array.
            </summary>
            <param name="Buffer"></param>
        </member>
        <member name="M:Inv.File.GetRelativePath">
            <summary>
            Relative path of the file to the installation root.
            </summary>
        </member>
        <member name="M:Inv.File.GetPlatformPath">
            <summary>
            Returns the fully qualified and platform-specific file path.
            Note that this is a leaky abstraction to the underlying platform implementation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.AsCsv">
            <summary>
            Treat this file as csv.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.AsIni">
            <summary>
            Treat this file as ini.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.AsText">
            <summary>
            Treat this file as text.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.AsCompact">
            <summary>
            Treat this file as compact (custom binary).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.File.AsSyntax(Inv.Syntax.Grammar)">
            <summary>
            Treat this file as syntax (custom structured text).
            </summary>
            <param name="Grammar"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.CompactFile">
            <summary>
            Compact file API.
            </summary>
        </member>
        <member name="M:Inv.CompactFile.Create">
            <summary>
            Create new or replace existing file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.CompactFile.Open">
            <summary>
            Open existing file for reading.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.CompactFile.Append">
            <summary>
            Append from the end of an existing file.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.CsvFile">
            <summary>
            Csv File API.
            </summary>
        </member>
        <member name="M:Inv.CsvFile.Create">
            <summary>
            Create new or replace existing file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.CsvFile.Open">
            <summary>
            Open existing file for reading.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.CsvFile.Append">
            <summary>
            Append from the end of an existing file.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.IniFile">
            <summary>
            Ini File API.
            </summary>
        </member>
        <member name="M:Inv.IniFile.Create">
            <summary>
            Create new or replace existing file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.IniFile.Open">
            <summary>
            Open existing file for reading.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.IniFile.Append">
            <summary>
            Append from the end of an existing file.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.TextFile">
            <summary>
            Text File API.
            </summary>
        </member>
        <member name="M:Inv.TextFile.Create">
            <summary>
            Create new or replace existing file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextFile.Open">
            <summary>
            Open existing file for reading.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextFile.Append">
            <summary>
            Append from the end of an existing file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextFile.Exists">
            <summary>
            Ask if the file exists in the owning folder.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextFile.ReadLines">
            <summary>
            Read all lines from the text file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextFile.ReadAll">
            <summary>
            Read the entire text file into a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TextFile.WriteAll(System.String)">
            <summary>
            Create new or replace existing file with a string.
            </summary>
            <param name="Text"></param>
        </member>
        <member name="T:Inv.SyntaxFile">
            <summary>
            Syntax File API.
            </summary>
        </member>
        <member name="M:Inv.SyntaxFile.Write(System.Action{Inv.Syntax.Writer})">
            <summary>
            Write the text file as structured syntax.
            </summary>
            <param name="FormatAction"></param>
        </member>
        <member name="M:Inv.SyntaxFile.Read(System.Action{Inv.Syntax.Reader})">
            <summary>
            Read the text file as structured syntax.
            </summary>
            <param name="ExtractAction"></param>
        </member>
        <member name="T:Inv.Element">
            <summary>
            The abstract element is the base class of the layout elements.
            </summary>
        </member>
        <member name="T:Inv.Edge">
            <summary>
            The abstract Edge is the base class of Margin and Padding.
            </summary>
        </member>
        <member name="P:Inv.Edge.Left">
            <summary>
            The left indent in logical points.
            </summary>
        </member>
        <member name="P:Inv.Edge.Top">
            <summary>
            The top indent in logical points.
            </summary>
        </member>
        <member name="P:Inv.Edge.Right">
            <summary>
            The right indent in logical points.
            </summary>
        </member>
        <member name="P:Inv.Edge.Bottom">
            <summary>
            The bottom indent in logical points.
            </summary>
        </member>
        <member name="P:Inv.Edge.IsSet">
            <summary>
            Ask if any of the indents are set.
            </summary>
        </member>
        <member name="P:Inv.Edge.IsUniform">
            <summary>
            Ask if all the indents are a uniform value.
            </summary>
        </member>
        <member name="P:Inv.Edge.IsHorizontal">
            <summary>
            Ask if the indents are set to the same value on the left and right.
            </summary>
        </member>
        <member name="P:Inv.Edge.IsVertical">
            <summary>
            Ask if the indents are set to the same value on the top and bottom.
            </summary>
        </member>
        <member name="M:Inv.Edge.Clear">
            <summary>
            Clear the indent.
            </summary>
        </member>
        <member name="M:Inv.Edge.Set(System.Int32)">
            <summary>
            Set a uniform indent.
            </summary>
            <param name="Value">The value used for the left, top, right and bottom indent</param>
        </member>
        <member name="M:Inv.Edge.Set(System.Int32,System.Int32)">
            <summary>
            Set a uniform indent for the horizontal and vertical.
            </summary>
            <param name="Horizontal">The value used for the left and right indent</param>
            <param name="Vertical">The value used for the top and bottom indent</param>
        </member>
        <member name="M:Inv.Edge.Set(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set a different indent for the left, top, right and bottom.
            </summary>
            <param name="Left"></param>
            <param name="Top"></param>
            <param name="Right"></param>
            <param name="Bottom"></param>
        </member>
        <member name="M:Inv.Edge.Set(Inv.Edge)">
            <summary>
            Set indents to match another edge.
            </summary>
            <param name="Edge"></param>
        </member>
        <member name="M:Inv.Edge.Is(System.Int32)">
            <summary>
            Ask if there is a uniform indent used on the left, top, right and bottom.
            </summary>
            <param name="Size">The indent size for comparison</param>
            <returns></returns>
        </member>
        <member name="M:Inv.Edge.Is(System.Int32,System.Int32)">
            <summary>
            Ask if there is a uniform indent for the horizontal and vertical.
            </summary>
            <param name="Horizontal"></param>
            <param name="Vertical"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Edge.Is(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Ask if there is a specific indent used.
            </summary>
            <param name="Left"></param>
            <param name="Top"></param>
            <param name="Right"></param>
            <param name="Bottom"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.Border">
            <summary>
            The outer edge of the panel can have a solid and coloured line.
            </summary>
        </member>
        <member name="P:Inv.Border.Colour">
            <summary>
            Colour of the border.
            </summary>
        </member>
        <member name="M:Inv.Border.Set(System.Int32)">
            <summary>
            Set a uniform border.
            </summary>
            <param name="Value">The value used for the left, top, right and bottom border</param>
            <returns>Returns this border so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Border.Set(System.Int32,System.Int32)">
            <summary>
            Set a uniform border for the horizontal and vertical.
            </summary>
            <param name="Horizontal">The value used for the left and right indent</param>
            <param name="Vertical">The value used for the top and bottom indent</param>
            <returns>Returns this border so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Border.Set(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set a different border for the left, top, right and bottom.
            </summary>
            <param name="Left"></param>
            <param name="Top"></param>
            <param name="Right"></param>
            <param name="Bottom"></param>
            <returns>Returns this border so you can chain calls in a fluent style.</returns>
        </member>
        <member name="T:Inv.Size">
            <summary>
            The dimensions of a panel including minimum and maximum constraints.
            </summary>
        </member>
        <member name="P:Inv.Size.Width">
            <summary>
            The fixed width of the panel in logical points. Null specifies auto width.
            </summary>
        </member>
        <member name="P:Inv.Size.Height">
            <summary>
            The fixed height of the panel in logical points. Null specifies auto height.
            </summary>
        </member>
        <member name="P:Inv.Size.MinimumWidth">
            <summary>
            The minimum width constraint of the panel in logical points. Null specifies no constraint.
            </summary>
        </member>
        <member name="P:Inv.Size.MinimumHeight">
            <summary>
            The minimum height constraint of the panel in logical points. Null specifies no constraint.
            </summary>
        </member>
        <member name="P:Inv.Size.MaximumWidth">
            <summary>
            The maximum width constraint of the panel in logical points. Null specifies no constraint.
            </summary>
        </member>
        <member name="P:Inv.Size.MaximumHeight">
            <summary>
            The maximum height constraint of the panel in logical points. Null specifies no constraint.
            </summary>
        </member>
        <member name="M:Inv.Size.Set(System.Nullable{System.Int32})">
            <summary>
            Set the fixed size of the panel.
            Use null to specify auto size.
            </summary>
            <param name="Size"></param>
        </member>
        <member name="M:Inv.Size.Set(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Set the fixed width and height of the panel.
            Use null to specify auto width or height.
            </summary>
            <param name="Width"></param>
            <param name="Height"></param>
        </member>
        <member name="M:Inv.Size.SetWidth(System.Nullable{System.Int32})">
            <summary>
            Set the fixed width of the panel.
            </summary>
            <param name="Width"></param>
        </member>
        <member name="M:Inv.Size.SetHeight(System.Nullable{System.Int32})">
            <summary>
            Set the fixed height of the panel.
            </summary>
            <param name="Height"></param>
        </member>
        <member name="M:Inv.Size.Is(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Ask if the panel has a fixed width and height.
            </summary>
            <param name="Width"></param>
            <param name="Height"></param>
        </member>
        <member name="M:Inv.Size.SetMinimum(System.Nullable{System.Int32})">
            <summary>
            Set the minimum width and height constraint of the panel.
            </summary>
            <param name="MinimumSize"></param>
        </member>
        <member name="M:Inv.Size.SetMinimum(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Set the minimum width and height of the panel.
            </summary>
            <param name="MinimumWidth"></param>
            /// <param name="MinimumHeight"></param>
        </member>
        <member name="M:Inv.Size.SetMinimumWidth(System.Nullable{System.Int32})">
            <summary>
            Set the minimum width constraint of the panel.
            </summary>
            <param name="MinimumWidth"></param>
        </member>
        <member name="M:Inv.Size.SetMinimumHeight(System.Nullable{System.Int32})">
            <summary>
            Set the minimum height constraint of the panel.
            </summary>
            <param name="MinimumHeight"></param>
        </member>
        <member name="M:Inv.Size.SetMaximum(System.Nullable{System.Int32})">
            <summary>
            Set the maximum width and height constraint of the panel.
            </summary>
            <param name="MaximumSize"></param>
        </member>
        <member name="M:Inv.Size.SetMaximum(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Set the maximum width and height constraint of the panel.
            </summary>
            <param name="MaximumWidth"></param>
            /// <param name="MaximumHeight"></param>
        </member>
        <member name="M:Inv.Size.SetMaximumWidth(System.Nullable{System.Int32})">
            <summary>
            Set the maximum width constraint of the panel.
            </summary>
            <param name="MaximumWidth"></param>
        </member>
        <member name="M:Inv.Size.SetMaximumHeight(System.Nullable{System.Int32})">
            <summary>
            Set the maximum height constraint of the panel.
            </summary>
            <param name="MaximumHeight"></param>
        </member>
        <member name="M:Inv.Size.Auto">
            <summary>
            Reset to automatic width and height.
            </summary>
        </member>
        <member name="M:Inv.Size.AutoWidth">
            <summary>
            Reset to automatic width.
            </summary>
        </member>
        <member name="M:Inv.Size.AutoHeight">
            <summary>
            Reset to automatic height.
            </summary>
        </member>
        <member name="M:Inv.Size.AutoMinimum">
            <summary>
            Reset to clear the minimum constraint.
            </summary>
        </member>
        <member name="M:Inv.Size.AutoMinimumWidth">
            <summary>
            Reset to clear the minimum width constraint.
            </summary>
        </member>
        <member name="M:Inv.Size.AutoMinimumHeight">
            <summary>
            Reset to clear the minimum height constraint.
            </summary>
        </member>
        <member name="M:Inv.Size.AutoMaximum">
            <summary>
            Reset to clear the maximum constraint.
            </summary>
        </member>
        <member name="M:Inv.Size.AutoMaximumWidth">
            <summary>
            Reset to clear the maximum width constraint.
            </summary>
        </member>
        <member name="M:Inv.Size.AutoMaximumHeight">
            <summary>
            Reset to clear the maximum height constraint.
            </summary>
        </member>
        <member name="T:Inv.Visibility">
            <summary>
            A panel can be collapsed which removes them from the layout.
            </summary>
        </member>
        <member name="M:Inv.Visibility.Get">
            <summary>
            Ask if the panel is visible.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Visibility.Set(System.Boolean)">
            <summary>
            Set the visibility of the panel.
            </summary>
            <param name="IsVisible"></param>
        </member>
        <member name="M:Inv.Visibility.Show">
            <summary>
            Show the panel.
            </summary>
        </member>
        <member name="M:Inv.Visibility.Collapse">
            <summary>
            Collapse the visibility of the panel.
            </summary>
        </member>
        <member name="M:Inv.Visibility.Toggle">
            <summary>
            Toggle the visibility of the panel.
            </summary>
        </member>
        <member name="T:Inv.Background">
            <summary>
            The solid background colour of a panel.
            </summary>
        </member>
        <member name="P:Inv.Background.Colour">
            <summary>
            Get and set the solid colour background.
            </summary>
        </member>
        <member name="T:Inv.Opacity">
            <summary>
            The percentage transparency of the panel and its children between 0 and 1.
            </summary>
        </member>
        <member name="M:Inv.Opacity.Get">
            <summary>
            Get the opacity of the panel between 0.0F and 1.0F.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Opacity.Set(System.Single)">
            <summary>
            Set the opacity of the panel between 0.0F and 1.0F.
            </summary>
            <param name="Percent"></param>
        </member>
        <member name="M:Inv.Opacity.Transparent">
            <summary>
            Make the panel completely transparent (0.0F).
            </summary>
        </member>
        <member name="M:Inv.Opacity.Opaque">
            <summary>
            Make the panel completely opaque (1.0F).
            </summary>
        </member>
        <member name="M:Inv.Opacity.IsOpaque">
            <summary>
            Panel is 100% opaque (completely visible, no transparency).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Opacity.IsTransparent">
            <summary>
            Panel is 100% transparent (completely invisible).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.Transform">
            <summary>
            Transformed panels.
            </summary>
        </member>
        <member name="M:Inv.Transform.GetScaleWidth">
            <summary>
            Get the scale width of the panel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Transform.GetScaleHeight">
            <summary>
            Get the scale height of the panel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Transform.Scale(System.Single)">
            <summary>
            Set the scale of the panel.
            </summary>
            <param name="Percent"></param>
        </member>
        <member name="M:Inv.Transform.ScaleWidth(System.Single)">
            <summary>
            Set the scale width of the panel.
            </summary>
            <param name="Percent"></param>
        </member>
        <member name="M:Inv.Transform.ScaleHeight(System.Single)">
            <summary>
            Set the scale height of the panel.
            </summary>
            <param name="Percent"></param>
        </member>
        <member name="T:Inv.Justify">
            <summary>
            Text justification (left, center, right).
            </summary>
        </member>
        <member name="M:Inv.Justify.Get">
            <summary>
            Get the justification of the text element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Justify.Set(Inv.Justification)">
            <summary>
            Set the justification of the text element.
            </summary>
            <param name="Justification"></param>
        </member>
        <member name="M:Inv.Justify.Left">
            <summary>
            Text is left aligned.
            </summary>
        </member>
        <member name="M:Inv.Justify.Center">
            <summary>
            Text is centered.
            </summary>
        </member>
        <member name="M:Inv.Justify.Right">
            <summary>
            Text is right aligned.
            </summary>
        </member>
        <member name="T:Inv.Justification">
            <summary>
            The enum used for text justification.
            </summary>
        </member>
        <member name="F:Inv.Justification.Left">
            <summary>
            Text is left aligned.
            </summary>
        </member>
        <member name="F:Inv.Justification.Center">
            <summary>
            Text is centered.
            </summary>
        </member>
        <member name="F:Inv.Justification.Right">
            <summary>
            Text is right aligned.
            </summary>
        </member>
        <member name="T:Inv.Alignment">
            <summary>
            The relative placement of a panel within its parent container.
            </summary>
        </member>
        <member name="M:Inv.Alignment.Get">
            <summary>
            Get the placement of the panel.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Alignment.Set(Inv.Placement)">
            <summary>
            Set the placement of the panel.
            </summary>
            <param name="Placement"></param>
        </member>
        <member name="M:Inv.Alignment.TopLeft">
            <summary>
            Align the panel to the top-left corner.
            </summary>
        </member>
        <member name="M:Inv.Alignment.TopCenter">
            <summary>
            Align the panel to the top and center.
            </summary>
        </member>
        <member name="M:Inv.Alignment.TopRight">
            <summary>
            Align the panel to the top-right corner.
            </summary>
        </member>
        <member name="M:Inv.Alignment.TopStretch">
            <summary>
            Align the panel to the top and stretch to the full width.
            </summary>
        </member>
        <member name="M:Inv.Alignment.CenterLeft">
            <summary>
            Align the panel to the vertical center and to the left edge.
            </summary>
        </member>
        <member name="M:Inv.Alignment.Center">
            <summary>
            Align the panel to the horizontal and vertical center.
            </summary>
        </member>
        <member name="M:Inv.Alignment.CenterRight">
            <summary>
            Align the panel to the vertical center and to the right edge.
            </summary>
        </member>
        <member name="M:Inv.Alignment.CenterStretch">
            <summary>
            Align the panel to the vertical center and stretch to the full width.
            </summary>
        </member>
        <member name="M:Inv.Alignment.BottomLeft">
            <summary>
            Align the panel to the bottom-left corner.
            </summary>
        </member>
        <member name="M:Inv.Alignment.BottomCenter">
            <summary>
            Align the panel to the bottom and horizontally center.
            </summary>
        </member>
        <member name="M:Inv.Alignment.BottomRight">
            <summary>
            Align the panel to the bottom-right corner.
            </summary>
        </member>
        <member name="M:Inv.Alignment.BottomStretch">
            <summary>
            Align the panel to the bottom and stretch to the full width.
            </summary>
        </member>
        <member name="M:Inv.Alignment.Stretch">
            <summary>
            Align the panel to stretch to the full width and height.
            </summary>
        </member>
        <member name="M:Inv.Alignment.StretchLeft">
            <summary>
            Align the panel to stretch to the full height and snap to the left edge.
            </summary>
        </member>
        <member name="M:Inv.Alignment.StretchRight">
            <summary>
            Align the panel to stretch to the full height and snap to the right edge.
            </summary>
        </member>
        <member name="M:Inv.Alignment.StretchCenter">
            <summary>
            Align the panel to stretch to the full height and horizontally center.
            </summary>
        </member>
        <member name="T:Inv.Placement">
            <summary>
            The enum used in panel alignment.
            </summary>
        </member>
        <member name="F:Inv.Placement.Stretch">
            <summary>
            vertical stretch and horizontal stretch
            </summary>
        </member>
        <member name="F:Inv.Placement.StretchLeft">
            <summary>
            vertical stretch and left
            </summary>
        </member>
        <member name="F:Inv.Placement.StretchCenter">
            <summary>
            vertical stretch and horizontal center
            </summary>
        </member>
        <member name="F:Inv.Placement.StretchRight">
            <summary>
            vertical stretch and right
            </summary>
        </member>
        <member name="F:Inv.Placement.TopStretch">
            <summary>
            top and horizontal stretch
            </summary>
        </member>
        <member name="F:Inv.Placement.TopLeft">
            <summary>
            top and left
            </summary>
        </member>
        <member name="F:Inv.Placement.TopCenter">
            <summary>
            top and horizontal center
            </summary>
        </member>
        <member name="F:Inv.Placement.TopRight">
            <summary>
            top and right
            </summary>
        </member>
        <member name="F:Inv.Placement.CenterStretch">
            <summary>
            vertical center and horizontal stretch
            </summary>
        </member>
        <member name="F:Inv.Placement.CenterLeft">
            <summary>
            vertical center and left
            </summary>
        </member>
        <member name="F:Inv.Placement.Center">
            <summary>
            vertical center and horizontal center
            </summary>
        </member>
        <member name="F:Inv.Placement.CenterRight">
            <summary>
            vertical center and right
            </summary>
        </member>
        <member name="F:Inv.Placement.BottomStretch">
            <summary>
            bottom and horizontal stretch
            </summary>
        </member>
        <member name="F:Inv.Placement.BottomLeft">
            <summary>
            bottom and left
            </summary>
        </member>
        <member name="F:Inv.Placement.BottomCenter">
            <summary>
            bottom and horizontal center
            </summary>
        </member>
        <member name="F:Inv.Placement.BottomRight">
            <summary>
            bottom and right
            </summary>
        </member>
        <member name="T:Inv.FontSize">
            <summary>
            Common font sizes.
            </summary>
        </member>
        <member name="F:Inv.FontSize.ExtraSmall">
            <summary>
            10pt.
            </summary>
        </member>
        <member name="F:Inv.FontSize.Small">
            <summary>
            11pt.
            </summary>
        </member>
        <member name="F:Inv.FontSize.Normal">
            <summary>
            12pt.
            </summary>
        </member>
        <member name="F:Inv.FontSize.Large">
            <summary>
            15pt.
            </summary>
        </member>
        <member name="F:Inv.FontSize.ExtraLarge">
            <summary>
            18pt.
            </summary>
        </member>
        <member name="F:Inv.FontSize.Massive">
            <summary>
            24pt.
            </summary>
        </member>
        <member name="F:Inv.FontSize.ExtraMassive">
            <summary>
            36pt.
            </summary>
        </member>
        <member name="T:Inv.Font">
            <summary>
            Font is used to render text in panels such as <see cref="T:Inv.Label" />, <see cref="T:Inv.Edit" /> and <see cref="T:Inv.Memo" />.
            </summary>
        </member>
        <member name="P:Inv.Font.Name">
            <summary>
            Family name of the font.
            Use with caution as not many fonts are available on all platforms.
            You can use <see cref="P:Inv.Device.Target"/> to select a different font per platform.
            </summary>
        </member>
        <member name="P:Inv.Font.Size">
            <summary>
            The size of the font in logical points.
            </summary>
        </member>
        <member name="P:Inv.Font.Colour">
            <summary>
            The colour of the font.
            </summary>
        </member>
        <member name="P:Inv.Font.Weight">
            <summary>
            The <see cref="T:Inv.FontWeight"/> of the font.
            </summary>
        </member>
        <member name="P:Inv.Font.IsItalics">
            <summary>
            Render as italics.
            </summary>
        </member>
        <member name="P:Inv.Font.IsUnderlined">
            <summary>
            Render with an underline.
            </summary>
        </member>
        <member name="P:Inv.Font.IsStrikethrough">
            <summary>
            Render with a strikethrough.
            </summary>
        </member>
        <member name="P:Inv.Font.IsSmallCaps">
            <summary>
            Render as small caps.
            </summary>
        </member>
        <member name="M:Inv.Font.IsSpecified">
            <summary>
            Returns true when at least one of the font fields has been specified.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Font.Monospaced">
            <summary>
            Set the font name to the default monospaced font for the device.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Proportional">
            <summary>
            Set the font name to the default proportional font for the device.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.ExtraSmall">
            <summary>
            Set font size to 10pt.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Small">
            <summary>
            Set font size to 11pt.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Normal">
            <summary>
            Set font size to 12pt.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Large">
            <summary>
            Set font size to 15pt.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.ExtraLarge">
            <summary>
            Set font size to 18pt.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Massive">
            <summary>
            Set font size to 24pt.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.ExtraMassive">
            <summary>
            Set font size to 36pt.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Custom(System.Int32)">
            <summary>
            Set font size to a custom size in pts.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Thin">
            <summary>
            Set the font weight to thin.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Light">
            <summary>
            Set the font weight to light.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Regular">
            <summary>
            Set the font weight to regular.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Medium">
            <summary>
            Set the font weight to medium.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Bold">
            <summary>
            Set the font weight to bold.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Heavy">
            <summary>
            Set the font weight to heavy.
            </summary>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Italics(System.Boolean)">
            <summary>
            Set Italics on (or off).
            </summary>
            <param name="On"></param>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Underlined(System.Boolean)">
            <summary>
            Set Underlined on (or off).
            </summary>
            <param name="On"></param>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.Strikethrough(System.Boolean)">
            <summary>
            Set Strikethrough on (or off).
            </summary>
            <param name="On"></param>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.SmallCaps(System.Boolean)">
            <summary>
            Set SmallCaps on (or off).
            </summary>
            <param name="On"></param>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="M:Inv.Font.In(Inv.Colour)">
            <summary>
            Set In(Colour).
            </summary>
            <param name="Colour"></param>
            <returns>Returns this font so you can chain calls in a fluent style.</returns>
        </member>
        <member name="T:Inv.FontWeight">
            <summary>
            The enum used for font weight.
            </summary>
        </member>
        <member name="F:Inv.FontWeight.Thin">
            <summary>
            thin font weight
            </summary>
        </member>
        <member name="F:Inv.FontWeight.Light">
            <summary>
            light font weight
            </summary>
        </member>
        <member name="F:Inv.FontWeight.Regular">
            <summary>
            regular font weight
            </summary>
        </member>
        <member name="F:Inv.FontWeight.Medium">
            <summary>
            medium font weight
            </summary>
        </member>
        <member name="F:Inv.FontWeight.Bold">
            <summary>
            bold font weight
            </summary>
        </member>
        <member name="F:Inv.FontWeight.Heavy">
            <summary>
            heavy font weight
            </summary>
        </member>
        <member name="T:Inv.Corner">
            <summary>
            Each corner of the panel can be rounded.
            </summary>
        </member>
        <member name="P:Inv.Corner.TopLeft">
            <summary>
            Top left corner in logical points.
            </summary>
        </member>
        <member name="P:Inv.Corner.TopRight">
            <summary>
            Top right corner in logical points.
            </summary>
        </member>
        <member name="P:Inv.Corner.BottomRight">
            <summary>
            Bottom right corner in logical points.
            </summary>
        </member>
        <member name="P:Inv.Corner.BottomLeft">
            <summary>
            Bottom left corner in logical points.
            </summary>
        </member>
        <member name="P:Inv.Corner.IsSet">
            <summary>
            Ask if any corners are set.
            </summary>
        </member>
        <member name="P:Inv.Corner.IsUniform">
            <summary>
            Ask if the corners are uniform.
            Returns true if the corners are not set.
            </summary>
        </member>
        <member name="M:Inv.Corner.Clear">
            <summary>
            Clear all corners.
            </summary>
        </member>
        <member name="M:Inv.Corner.Set(System.Int32)">
            <summary>
            Set all corners to a uniform value.
            </summary>
            <param name="Value"></param>
        </member>
        <member name="M:Inv.Corner.Set(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set the individual corners.
            </summary>
            <param name="TopLeft"></param>
            <param name="TopRight"></param>
            <param name="BottomRight"></param>
            <param name="BottomLeft"></param>
        </member>
        <member name="M:Inv.Corner.Is(System.Int32)">
            <summary>
            Ask if the corners are conformant to a uniform value.
            </summary>
            <param name="Size"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Corner.Is(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Ask if the individual corners are conformant.
            </summary>
            <param name="TopLeft"></param>
            <param name="TopRight"></param>
            <param name="BottomRight"></param>
            <param name="BottomLeft"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.Margin">
            <summary>
            The outside spacing for a panel on all four sides.
            </summary>
        </member>
        <member name="T:Inv.Padding">
            <summary>
            The inside spacing for a panel on all four sides.
            </summary>
        </member>
        <member name="T:Inv.Elevation">
            <summary>
            This is the relative depth between panels along the z-axis.
            </summary>
        </member>
        <member name="M:Inv.Elevation.Clear">
            <summary>
            Reset the elevation to zero.
            </summary>
        </member>
        <member name="M:Inv.Elevation.Get">
            <summary>
            Get the elevation in logical points.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Elevation.Set(System.Int32)">
            <summary>
            Set the elevation in logical points.
            </summary>
            <param name="Depth"></param>
        </member>
        <member name="T:Inv.TableAxis">
            <summary>
            Represents a row or column in a table.
            </summary>
        </member>
        <member name="P:Inv.TableAxis.Index">
            <summary>
            Index location of the row or column.
            </summary>
        </member>
        <member name="P:Inv.TableAxis.Content">
            <summary>
            Content for the entire row or column.
            This is placed behind the cell content.
            </summary>
        </member>
        <member name="M:Inv.TableAxis.Auto">
            <summary>
            Set the row or column to auto size.
            </summary>
        </member>
        <member name="M:Inv.TableAxis.Fixed(System.Int32)">
            <summary>
            Set the row or column to fixed size.
            </summary>
            <param name="Points"></param>
        </member>
        <member name="M:Inv.TableAxis.Star(System.Int32)">
            <summary>
            Set the row or column to star size.
            </summary>
            <param name="Units"></param>
        </member>
        <member name="T:Inv.TableRow">
            <summary>
            Row in a table.
            </summary>
        </member>
        <member name="M:Inv.TableRow.GetCells">
            <summary>
            Enumerate the cells in this row.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TableRow.Compose(Inv.Panel[])">
            <summary>
            Apply the panels to the cells in this row.
            </summary>
            <param name="PanelArray"></param>
        </member>
        <member name="T:Inv.TableColumn">
            <summary>
            Column in a table.
            </summary>
        </member>
        <member name="M:Inv.TableColumn.GetCells">
            <summary>
            Enumerate the cells in this column.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.TableColumn.Compose(Inv.Panel[])">
            <summary>
            Apply the panels to the cells in this column.
            </summary>
            <param name="PanelArray"></param>
        </member>
        <member name="T:Inv.TableCell">
            <summary>
            Cell in a table.
            </summary>
        </member>
        <member name="P:Inv.TableCell.X">
            <summary>
            X position of the cell.
            </summary>
        </member>
        <member name="P:Inv.TableCell.Y">
            <summary>
            Y position of the cell.
            </summary>
        </member>
        <member name="P:Inv.TableCell.Column">
            <summary>
            Owning column of the cell.
            </summary>
        </member>
        <member name="P:Inv.TableCell.Row">
            <summary>
            Owning row of the cell.
            </summary>
        </member>
        <member name="P:Inv.TableCell.Content">
            <summary>
            Content in the cell.
            </summary>
        </member>
        <member name="T:Inv.Focus">
            <summary>
            Focus manager for a panel.
            </summary>
        </member>
        <member name="E:Inv.Focus.GotEvent">
            <summary>
            Handle to be notified when the panel receives focus.
            </summary>
        </member>
        <member name="M:Inv.Focus.HasGot">
            <summary>
            Returns true if the GotEvent is handled on this panel.
            </summary>
        </member>
        <member name="E:Inv.Focus.LostEvent">
            <summary>
            Handle to be notified when the panel loses focus.
            </summary>
        </member>
        <member name="M:Inv.Focus.HasLost">
            <summary>
            Returns true if the LostEvent is handled on this panel.
            </summary>
        </member>
        <member name="M:Inv.Focus.Has">
            <summary>
            Gets whether this panel currently has logical focus.
            </summary>
        </member>
        <member name="M:Inv.Focus.Set">
            <summary>
            Set the focus to this panel.
            </summary>
        </member>
        <member name="T:Inv.Tooltip">
            <summary>
            Tooltip that appears when a user hovers over a panel with a mouse pointer.
            </summary>
        </member>
        <member name="E:Inv.Tooltip.ShowEvent">
            <summary>
            Handle to be notified when the tooltip is shown.
            </summary>
        </member>
        <member name="M:Inv.Tooltip.HasShow">
            <summary>
            Returns true if the ShowEvent is handled on this tooltip.
            </summary>
        </member>
        <member name="E:Inv.Tooltip.HideEvent">
            <summary>
            Handle to be notified when the tooltip is hidden.
            </summary>
        </member>
        <member name="M:Inv.Tooltip.HasHide">
            <summary>
            Returns true if the HideEvent is handled on this tooltip.
            </summary>
        </member>
        <member name="P:Inv.Tooltip.IsActive">
            <summary>
            Returns true if the tooltip is currently shown.
            </summary>
        </member>
        <member name="P:Inv.Tooltip.Content">
            <summary>
            Content of the tooltip.
            </summary>
        </member>
        <member name="T:Inv.Email">
            <summary>
            See <see cref="P:Inv.Application.Email"/>
            </summary>
        </member>
        <member name="M:Inv.Email.NewMessage">
            <summary>
            Start a new email message.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.EmailMessage">
            <summary>
            Populate an email message before prompting to send in the default mail app.
            </summary>
        </member>
        <member name="P:Inv.EmailMessage.Subject">
            <summary>
            Subject of the email.
            </summary>
        </member>
        <member name="P:Inv.EmailMessage.Body">
            <summary>
            Plain text body of the email.
            </summary>
        </member>
        <member name="M:Inv.EmailMessage.To(System.String,System.String)">
            <summary>
            The email To field will be filled in with the recipients.
            </summary>
            <param name="RecipientName"></param>
            <param name="RecipientAddress"></param>
        </member>
        <member name="M:Inv.EmailMessage.Attach(System.String,Inv.File)">
            <summary>
            Attach a file to the email.
            </summary>
            <param name="DisplayName"></param>
            <param name="File"></param>
        </member>
        <member name="M:Inv.EmailMessage.Send">
            <summary>
            Open the populated email in the default mail app so the user can send.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.Graphics">
            <summary>
            See <see cref="P:Inv.Application.Graphics"/>.
            </summary>
        </member>
        <member name="M:Inv.Graphics.GetDimension(Inv.Image)">
            <summary>
            Get the dimensions (width, height) of the image.
            </summary>
            <param name="Image"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Graphics.Grayscale(Inv.Image)">
            <summary>
            Convert the image into a grayscale version.
            </summary>
            <param name="Image"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Graphics.Tint(Inv.Image,Inv.Colour)">
            <summary>
            Tint the input image with the provided colour.
            </summary>
            <param name="Image"></param>
            <param name="Colour"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Graphics.Resize(Inv.Image,Inv.Dimension)">
            <summary>
            Resize the input image to the specified dimension.
            </summary>
            <param name="Image"></param>
            <param name="Dimension"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Graphics.ReadPixels(Inv.Image)">
            <summary>
            Extract a grid of colour pixels from the source image.
            </summary>
            <param name="Image"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Graphics.WritePixels(Inv.Pixels)">
            <summary>
            Compose an image from a grid of colour pixels.
            </summary>
            <param name="Pixels"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.Haptics">
            <summary>
            See <see cref="P:Inv.Application.Haptics"/>
            </summary>
        </member>
        <member name="P:Inv.Haptics.IsSupported">
            <summary>
            Informs if the current device supports haptic feedback.
            </summary>
        </member>
        <member name="M:Inv.Haptics.LightImpact">
            <summary>
            iOS: Triggers a light impact haptic feedback
            <para />
            AOSP: Triggers a ContextClick haptic feedback
            </summary>
        </member>
        <member name="M:Inv.Haptics.MediumImpact">
            <summary>
            iOS: Triggers a medium impact haptic feedback
            <para />
            AOSP: Triggers a KeyboardTap haptic feedback
            </summary>
        </member>
        <member name="M:Inv.Haptics.HeavyImpact">
            <summary>
            iOS: Triggers a heavy impact haptic feedback
            <para />
            AOSP: Triggers a LongPress haptic feedback
            </summary>
        </member>
        <member name="M:Inv.Haptics.Feedback(Inv.HapticFeedback)">
            <summary>
            Trigger haptic feedback with type specified by the parameter.
            </summary>
            <param name="Feedback"></param>
        </member>
        <member name="T:Inv.JsonHelper">
            <summary>
            Json Convertors.
            </summary>
        </member>
        <member name="F:Inv.JsonHelper.BaseConverter">
            <summary>
            Invention Json Convertor.
            </summary>
        </member>
        <member name="M:Inv.JsonHelper.NewSerializerSettings">
            <summary>
            Get default Inv settings.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.JsonSerializer">
            <summary>
            Json serialization helper.
            </summary>
        </member>
        <member name="P:Inv.JsonSerializer.IgnoreErrors">
            <summary>
            Ignores any Json serialization errors (true by default).
            </summary>
        </member>
        <member name="M:Inv.JsonSerializer.Load``1(System.String)">
            <summary>
            Deserialize a Json object from the input text.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Text"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.JsonSerializer.Save(System.Object)">
            <summary>
            Serialize the object to Json text.
            </summary>
            <param name="ObjectValue"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.JsonConverter">
            <summary>
            Invention Json Convertor.
            </summary>
        </member>
        <member name="M:Inv.JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Writes the JSON representation of the object.
            </summary>
            <param name="Writer"></param>
            <param name="Value"></param>
            <param name="Serializer"></param>
        </member>
        <member name="M:Inv.JsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Reads the JSON representation of the object.
            </summary>
            <param name="Reader"></param>
            <param name="ObjectType"></param>
            <param name="ExistingValue"></param>
            <param name="Serializer"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.JsonConverter.CanConvert(System.Type)">
            <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
            <param name="ObjectType"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.Key">
            <summary>
            Cross-platform key enumeration.
            </summary>
        </member>
        <member name="F:Inv.Key.A">
            <summary>
            Letter A.
            </summary>
        </member>
        <member name="F:Inv.Key.B">
            <summary>
            Letter B.
            </summary>
        </member>
        <member name="F:Inv.Key.C">
            <summary>
            Letter C.
            </summary>
        </member>
        <member name="F:Inv.Key.D">
            <summary>
            Letter D.
            </summary>
        </member>
        <member name="F:Inv.Key.E">
            <summary>
            Letter E.
            </summary>
        </member>
        <member name="F:Inv.Key.F">
            <summary>
            Letter F.
            </summary>
        </member>
        <member name="F:Inv.Key.G">
            <summary>
            Letter G.
            </summary>
        </member>
        <member name="F:Inv.Key.H">
            <summary>
            Letter H.
            </summary>
        </member>
        <member name="F:Inv.Key.I">
            <summary>
            Letter I.
            </summary>
        </member>
        <member name="F:Inv.Key.J">
            <summary>
            Letter J.
            </summary>
        </member>
        <member name="F:Inv.Key.K">
            <summary>
            Letter K.
            </summary>
        </member>
        <member name="F:Inv.Key.L">
            <summary>
            Letter L.
            </summary>
        </member>
        <member name="F:Inv.Key.M">
            <summary>
            Letter M.
            </summary>
        </member>
        <member name="F:Inv.Key.N">
            <summary>
            Letter N.
            </summary>
        </member>
        <member name="F:Inv.Key.O">
            <summary>
            Letter O.
            </summary>
        </member>
        <member name="F:Inv.Key.P">
            <summary>
            Letter P.
            </summary>
        </member>
        <member name="F:Inv.Key.Q">
            <summary>
            Letter Q.
            </summary>
        </member>
        <member name="F:Inv.Key.R">
            <summary>
            Letter R.
            </summary>
        </member>
        <member name="F:Inv.Key.S">
            <summary>
            Letter S.
            </summary>
        </member>
        <member name="F:Inv.Key.T">
            <summary>
            Letter T.
            </summary>
        </member>
        <member name="F:Inv.Key.U">
            <summary>
            Letter U.
            </summary>
        </member>
        <member name="F:Inv.Key.V">
            <summary>
            Letter V.
            </summary>
        </member>
        <member name="F:Inv.Key.W">
            <summary>
            Letter W.
            </summary>
        </member>
        <member name="F:Inv.Key.X">
            <summary>
            Letter X.
            </summary>
        </member>
        <member name="F:Inv.Key.Y">
            <summary>
            Letter Y.
            </summary>
        </member>
        <member name="F:Inv.Key.Z">
            <summary>
            Letter Z.
            </summary>
        </member>
        <member name="F:Inv.Key.n0">
            <summary>
            Number 0.
            </summary>
        </member>
        <member name="F:Inv.Key.n1">
            <summary>
            Number 1.
            </summary>
        </member>
        <member name="F:Inv.Key.n2">
            <summary>
            Number 2.
            </summary>
        </member>
        <member name="F:Inv.Key.n3">
            <summary>
            Number 3.
            </summary>
        </member>
        <member name="F:Inv.Key.n4">
            <summary>
            Number 4.
            </summary>
        </member>
        <member name="F:Inv.Key.n5">
            <summary>
            Number 5.
            </summary>
        </member>
        <member name="F:Inv.Key.n6">
            <summary>
            Number 6.
            </summary>
        </member>
        <member name="F:Inv.Key.n7">
            <summary>
            Number 7.
            </summary>
        </member>
        <member name="F:Inv.Key.n8">
            <summary>
            Number 8.
            </summary>
        </member>
        <member name="F:Inv.Key.n9">
            <summary>
            Number 9.
            </summary>
        </member>
        <member name="F:Inv.Key.F1">
            <summary>
            Function Key 1.
            </summary>
        </member>
        <member name="F:Inv.Key.F2">
            <summary>
            Function Key 2.
            </summary>
        </member>
        <member name="F:Inv.Key.F3">
            <summary>
            Function Key 3.
            </summary>
        </member>
        <member name="F:Inv.Key.F4">
            <summary>
            Function Key 4.
            </summary>
        </member>
        <member name="F:Inv.Key.F5">
            <summary>
            Function Key 5.
            </summary>
        </member>
        <member name="F:Inv.Key.F6">
            <summary>
            Function Key 6.
            </summary>
        </member>
        <member name="F:Inv.Key.F7">
            <summary>
            Function Key 7.
            </summary>
        </member>
        <member name="F:Inv.Key.F8">
            <summary>
            Function Key 8.
            </summary>
        </member>
        <member name="F:Inv.Key.F9">
            <summary>
            Function Key 9.
            </summary>
        </member>
        <member name="F:Inv.Key.F10">
            <summary>
            Function Key 10.
            </summary>
        </member>
        <member name="F:Inv.Key.F11">
            <summary>
            Function Key 11.
            </summary>
        </member>
        <member name="F:Inv.Key.F12">
            <summary>
            Function Key 12.
            </summary>
        </member>
        <member name="F:Inv.Key.Period">
            <summary>
            Period (.)
            </summary>
        </member>
        <member name="F:Inv.Key.Tilde">
            <summary>
            Tilde (~)
            </summary>
        </member>
        <member name="F:Inv.Key.SingleQuote">
            <summary>
            Single Quote (`)
            </summary>
        </member>
        <member name="F:Inv.Key.DoubleQuote">
            <summary>
            Double Quote (`)
            </summary>
        </member>
        <member name="F:Inv.Key.BackQuote">
            <summary>
            Back Quote (`)
            </summary>
        </member>
        <member name="F:Inv.Key.Asterisk">
            <summary>
            Asterisk (*)
            </summary>
        </member>
        <member name="F:Inv.Key.Comma">
            <summary>
            Comma (,)
            </summary>
        </member>
        <member name="F:Inv.Key.Escape">
            <summary>
            Escape (Esc)
            </summary>
        </member>
        <member name="F:Inv.Key.Enter">
            <summary>
            Enter
            </summary>
        </member>
        <member name="F:Inv.Key.Tab">
            <summary>
            Tab
            </summary>
        </member>
        <member name="F:Inv.Key.Space">
            <summary>
            Space
            </summary>
        </member>
        <member name="F:Inv.Key.Insert">
            <summary>
            Insert (Ins)
            </summary>
        </member>
        <member name="F:Inv.Key.Delete">
            <summary>
            Delete (Del)
            </summary>
        </member>
        <member name="F:Inv.Key.Up">
            <summary>
            Arrow Up
            </summary>
        </member>
        <member name="F:Inv.Key.Down">
            <summary>
            Arrow Down
            </summary>
        </member>
        <member name="F:Inv.Key.Left">
            <summary>
            Arrow Left
            </summary>
        </member>
        <member name="F:Inv.Key.Right">
            <summary>
            Arrow Right
            </summary>
        </member>
        <member name="F:Inv.Key.Home">
            <summary>
            Home
            </summary>
        </member>
        <member name="F:Inv.Key.PageUp">
            <summary>
            Page Up (PgUp)
            </summary>
        </member>
        <member name="F:Inv.Key.End">
            <summary>
            End
            </summary>
        </member>
        <member name="F:Inv.Key.PageDown">
            <summary>
            Page Down (PgDn)
            </summary>
        </member>
        <member name="F:Inv.Key.Clear">
            <summary>
            Clear
            </summary>
        </member>
        <member name="F:Inv.Key.Slash">
            <summary>
            Slash (/)
            </summary>
        </member>
        <member name="F:Inv.Key.Backslash">
            <summary>
            Backslash (\)
            </summary>
        </member>
        <member name="F:Inv.Key.Plus">
            <summary>
            Plus (+)
            </summary>
        </member>
        <member name="F:Inv.Key.Minus">
            <summary>
            Minus (-)
            </summary>
        </member>
        <member name="F:Inv.Key.Backspace">
            <summary>
            Backspace
            </summary>
        </member>
        <member name="F:Inv.Key.LeftShift">
            <summary>
            Left shift
            </summary>
        </member>
        <member name="F:Inv.Key.RightShift">
            <summary>
            Right shift
            </summary>
        </member>
        <member name="F:Inv.Key.LeftAlt">
            <summary>
            Left alt
            </summary>
        </member>
        <member name="F:Inv.Key.RightAlt">
            <summary>
            Right alt
            </summary>
        </member>
        <member name="F:Inv.Key.LeftCtrl">
            <summary>
            Left ctrl
            </summary>
        </member>
        <member name="F:Inv.Key.RightCtrl">
            <summary>
            Right ctrl
            </summary>
        </member>
        <member name="T:Inv.KeyModifier">
            <summary>
            Cross-platform key modifier.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsNone">
            <summary>
            Is there no modifier keys pressed.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsLeftShift">
            <summary>
            Is the left shift pressed.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsRightShift">
            <summary>
            Is the right shift pressed.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsShift">
            <summary>
            Is the shift pressed.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsLeftAlt">
            <summary>
            Is the left alt pressed.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsRightAlt">
            <summary>
            Is the right alt pressed.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsAlt">
            <summary>
            Is the alt pressed.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsLeftCtrl">
            <summary>
            Is the left ctrl pressed.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsRightCtrl">
            <summary>
            Is the right ctrl pressed.
            </summary>
        </member>
        <member name="P:Inv.KeyModifier.IsCtrl">
            <summary>
            Is the ctrl pressed.
            </summary>
        </member>
        <member name="M:Inv.KeyModifier.ToString">
            <summary>
            Render the key modifier to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.KeyModifier.IsEqual(Inv.KeyModifier)">
            <summary>
            Equality comparison for two key modifiers.
            </summary>
            <param name="KeyModifier"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.Keystroke">
            <summary>
            The keystroke is the <see cref="P:Inv.Keystroke.Key"/> that was pressed and the <see cref="P:Inv.Keystroke.Modifier"/>.
            </summary>
        </member>
        <member name="P:Inv.Keystroke.Key">
            <summary>
            The key pressed.
            </summary>
        </member>
        <member name="P:Inv.Keystroke.Modifier">
            <summary>
            Any active modifiers such as shift, ctrl or alt.
            </summary>
        </member>
        <member name="M:Inv.Keystroke.ToString">
            <summary>
            Render the keystroke to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.Location">
            <summary>
            See <see cref="P:Inv.Application.Location"/>
            </summary>
        </member>
        <member name="P:Inv.Location.IsSupported">
            <summary>
            Ask if this device supports location services.
            </summary>
        </member>
        <member name="M:Inv.Location.Lookup(Inv.Coordinate,System.Action{Inv.LocationResult})">
            <summary>
            Async reverse geocode lookup.
            </summary>
            <param name="Coordinate">The coordinate to lookup.</param>
            <param name="ResultAction">Fired when a result is found.</param>
        </member>
        <member name="M:Inv.Location.ShowMap(System.String)">
            <summary>
            Launch the specified location (such as a street address) in the default map viewer.
            </summary>
            <param name="Location"></param>
        </member>
        <member name="T:Inv.LocationResult">
            <summary>
            The result of a reverse geocode loookup.
            </summary>
        </member>
        <member name="P:Inv.LocationResult.Coordinate">
            <summary>
            Coordinate location.
            </summary>
        </member>
        <member name="M:Inv.LocationResult.GetPlacemarks">
            <summary>
            Enumerable the list of matching placemarks.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.LocationPlacemark">
            <summary>
            The placemark are points of interest by latitude and longitude.
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.Name">
            <summary>
            Street.
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.Locality">
            <summary>
            Suburb.
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.SubLocality">
            <summary>
            City.
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.PostalCode">
            <summary>
            Postal code
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.AdministrativeArea">
            <summary>
            State.
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.SubAdministrativeArea">
            <summary>
            Area.
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.CountryName">
            <summary>
            Country name.
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.CountryCode">
            <summary>
            Country code.
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.Latitude">
            <summary>
            Latitude of placemark.
            </summary>
        </member>
        <member name="P:Inv.LocationPlacemark.Longitude">
            <summary>
            Longitude of placemark.
            </summary>
        </member>
        <member name="M:Inv.LocationPlacemark.ToCanonical">
            <summary>
            Convert this placemark to a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.LocationPlacemark.FromCanonical(System.String)">
            <summary>
            Convert from a string to a new placemark.
            </summary>
            <param name="Text"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.Market">
            <summary>
            See <see cref="P:Inv.Application.Market"/>
            </summary>
        </member>
        <member name="M:Inv.Market.Browse(System.String,System.String,System.String)">
            <summary>
            Browse to the app listing in the current platform's app store.
            The parameter example are the values for the Invention Manual app.
            </summary>
            <param name="AppleiTunesID">eg. "1195335633"</param>
            <param name="GooglePlayID">eg. "com.x10host.invention.manual"</param>
            <param name="WindowsStoreID">eg. "808CallanHodgskin.InventionManual_ax6pb6c2q0eqa"</param>
        </member>
        <member name="T:Inv.Panel">
            <summary>
            The Panel is an interface contract which publishes a base control.
            This interface is necessary so subclasses can be used for custom controls.
            </summary>
        </member>
        <member name="P:Inv.Panel.Control">
            <summary>
            The base control of the panel.
            </summary>
        </member>
        <member name="T:Inv.Control">
            <summary>
            The abstract panel is the base class of the layout panels.
            </summary>
        </member>
        <member name="P:Inv.Control.Window">
            <summary>
            The controlling <see cref="T:Inv.Window"/> for this panel.
            </summary>
        </member>
        <member name="P:Inv.Control.Opacity">
            <summary>
            The percentage transparency of the panel and its children between 0 and 1.
            </summary>
        </member>
        <member name="P:Inv.Control.Background">
            <summary>
            Each panel has a background colour.
            Colour opacity is supported to allow the full ARGB colour range.
            </summary>
        </member>
        <member name="P:Inv.Control.Corner">
            <summary>
            Each corner of the panel can be rounded.
            This is used for style reasons such as circular panels.
            </summary>
        </member>
        <member name="P:Inv.Control.Border">
            <summary>
            The outer edge of the panel can have a solid and coloured line.
            The border is drawn on inside of the margin and the outside of the padding.
            </summary>
        </member>
        <member name="P:Inv.Control.Alignment">
            <summary>
            The relative placement of a panel within its parent container.
            It is a key technique for laying out panels.
            </summary>
        </member>
        <member name="P:Inv.Control.Visibility">
            <summary>
            A panel can be collapsed which removes them from the layout.
            Hidden panels that reserve their space are not supported.
            </summary>
        </member>
        <member name="P:Inv.Control.Size">
            <summary>
            The width and height of panel can be explicitly set.
            Minimum and maximum constraints can also be set.
            </summary>
        </member>
        <member name="P:Inv.Control.Margin">
            <summary>
            The outside spacing for a panel on all four sides.
            This is for gaps between adjacent panels.
            </summary>
        </member>
        <member name="P:Inv.Control.Padding">
            <summary>
            The inside spacing for a panel on all four sides.
            This is used to indent the content inside a panel.
            </summary>
        </member>
        <member name="P:Inv.Control.Elevation">
            <summary>
            This is the relative depth between panels along the z-axis.
            It is used to indicate distances by the depth of the shadow.
            </summary>
        </member>
        <member name="E:Inv.Control.AdjustEvent">
            <summary>
            Handle this event to know when the dimension of the panel have changed.
            </summary>
        </member>
        <member name="P:Inv.Control.HasAdjust">
            <summary>
            Returns true if the AdjustEvent is handled on this panel.
            </summary>
        </member>
        <member name="M:Inv.Control.Readjust">
            <summary>
            Programmatically invoke an adjust (fires <see cref="E:Inv.Control.AdjustEvent"/>).
            </summary>
        </member>
        <member name="M:Inv.Control.GetDimension">
            <summary>
            Request the current dimension of the panel once it is in the visual tree, otherwise Inv.Dimension.Zero is returned.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.Orientation">
            <summary>
            Horizontal or vertical orientation.
            </summary>
        </member>
        <member name="F:Inv.Orientation.Horizontal">
            <summary>
            Horizontal orientation means left-to-right
            </summary>
        </member>
        <member name="F:Inv.Orientation.Vertical">
            <summary>
            Vertical orientations means top-to-bottom
            </summary>
        </member>
        <member name="T:Inv.Overlay">
            <summary>
            This layout is Z-order stack where the panels are placed on top of each other.
            Alignment can be used to layout the panels inside the overlay.
            </summary>
        </member>
        <member name="M:Inv.Overlay.#ctor">
            <summary>
            Create a new overlay.
            </summary>
        </member>
        <member name="M:Inv.Overlay.New">
            <summary>
            Create a new overlay.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Overlay.PanelCount">
            <summary>
            Number of panels in the overlay.
            </summary>
        </member>
        <member name="M:Inv.Overlay.AddPanel(Inv.Panel)">
            <summary>
            Add a panel on top of the overlaid panels.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Overlay.InsertPanel(System.Int32,Inv.Panel)">
            <summary>
            Insert a panel at a specified position in the overlaid panels.
            </summary>
            <param name="Index"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Overlay.InsertPanelBefore(Inv.Panel,Inv.Panel)">
            <summary>
            Insert a panel before another panel in the overlay.
            </summary>
            <param name="Before"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Overlay.InsertPanelAfter(Inv.Panel,Inv.Panel)">
            <summary>
            Insert a panel after another panel in the overlay.
            </summary>
            <param name="After"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Overlay.RemovePanel(Inv.Panel)">
            <summary>
            Remove a specific panel from the overlay.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Overlay.RemovePanels">
            <summary>
            Remove all panels from the overlay.
            </summary>
        </member>
        <member name="M:Inv.Overlay.HasPanel(Inv.Panel)">
            <summary>
            Ask if the overlay contains a panel.
            </summary>
            <param name="Panel"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Overlay.GetPanels">
            <summary>
            Enumerate all panels in the overlay (in z-order).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Overlay.ComposePanels(Inv.Panel[])">
            <summary>
            Replace all the panels with the provided panel array.
            </summary>
            <param name="PanelArray"></param>
        </member>
        <member name="T:Inv.Stack">
            <summary>
            Stacks are for horizontal and vertical linear layout of panels.
            Stacked panels are arranged in the order they were added.
            </summary>
        </member>
        <member name="M:Inv.Stack.#ctor(Inv.Orientation)">
            <summary>
            Create a new stack.
            </summary>
            <param name="Orientation"></param>
        </member>
        <member name="M:Inv.Stack.New(Inv.Orientation)">
            <summary>
            Create a new stack.
            </summary>
            <param name="Orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Stack.NewVertical">
            <summary>
            Create a new vertical stack.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Stack.NewHorizontal">
            <summary>
            Create a new horizontal stack.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Stack.Orientation">
            <summary>
            Orientation of the stacked panels.
            </summary>
        </member>
        <member name="P:Inv.Stack.IsHorizontal">
            <summary>
            Ask if the panels are stacked horizontally.
            </summary>
        </member>
        <member name="P:Inv.Stack.IsVertical">
            <summary>
            Ask if the panels are stacked vertically.
            </summary>
        </member>
        <member name="P:Inv.Stack.PanelCount">
            <summary>
            Number of panels in the stack.
            </summary>
        </member>
        <member name="M:Inv.Stack.SetHorizontal">
            <summary>
            Change the stacked panels to a horizontal orientation.
            </summary>
        </member>
        <member name="M:Inv.Stack.SetVertical">
            <summary>
            Change the stacked panels to a vertical orientation.
            </summary>
        </member>
        <member name="M:Inv.Stack.SetOrientation(Inv.Orientation)">
            <summary>
            Set the orientation of the stacked panels.
            </summary>
            <param name="Orientation"></param>
        </member>
        <member name="M:Inv.Stack.AddPanel(Inv.Panel)">
            <summary>
            Add a panel to the end of the stack.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Stack.InsertPanel(System.Int32,Inv.Panel)">
            <summary>
            Insert a panel at a specified location in the stack.
            </summary>
            <param name="Index"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Stack.RemovePanels">
            <summary>
            Remove all the panels from the stack.
            </summary>
        </member>
        <member name="M:Inv.Stack.RemovePanel(Inv.Panel)">
            <summary>
            Remove a specific panel from the stack.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Stack.InsertPanelBefore(Inv.Panel,Inv.Panel)">
            <summary>
            Insert a panel before another panel in the stack.
            </summary>
            <param name="Before"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Stack.InsertPanelAfter(Inv.Panel,Inv.Panel)">
            <summary>
            Insert a panel after another panel in the stack.
            </summary>
            <param name="After"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Stack.HasPanel(Inv.Panel)">
            <summary>
            Ask if the stack contains a panel.
            </summary>
            <param name="Panel"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Stack.HasPanels">
            <summary>
            Ask if the stack contains any panels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Stack.GetPanels">
            <summary>
            Enumerate the panels in the stack (in stacked order).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Stack.ComposePanels(Inv.Panel[])">
            <summary>
            Replace all the panels with the provided panel array.
            </summary>
            <param name="PanelArray"></param>
        </member>
        <member name="T:Inv.Dock">
            <summary>
            Docks are for horizontal and vertical linear layout of panels.
            Docked panels are arranged in the order they were added.
            </summary>
        </member>
        <member name="M:Inv.Dock.#ctor(Inv.Orientation)">
            <summary>
            Create a new dock.
            </summary>
            <param name="Orientation"></param>
        </member>
        <member name="M:Inv.Dock.New(Inv.Orientation)">
            <summary>
            Create a new dock.
            </summary>
            <param name="Orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.NewVertical">
            <summary>
            Create a new vertical dock.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.NewHorizontal">
            <summary>
            Create a new horizontal dock.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Dock.Orientation">
            <summary>
            Orientation of the docked panels.
            </summary>
        </member>
        <member name="P:Inv.Dock.IsHorizontal">
            <summary>
            Ask if the panels are docked horizontally.
            </summary>
        </member>
        <member name="P:Inv.Dock.IsVertical">
            <summary>
            Ask if the panels are docked vertically.
            </summary>
        </member>
        <member name="P:Inv.Dock.PanelCount">
            <summary>
            Number of panels in the dock.
            </summary>
        </member>
        <member name="M:Inv.Dock.SetHorizontal">
            <summary>
            Change the docked panels to a horizontal orientation.
            </summary>
        </member>
        <member name="M:Inv.Dock.SetVertical">
            <summary>
            Change the docked panels to a vertical orientation.
            </summary>
        </member>
        <member name="M:Inv.Dock.SetOrientation(Inv.Orientation)">
            <summary>
            Set the orientation of the docked panels.
            </summary>
            <param name="Orientation"></param>
        </member>
        <member name="M:Inv.Dock.HasPanels">
            <summary>
            Ask if the dock contains any panels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.RemovePanels">
            <summary>
            Remove all panels from the dock.
            </summary>
        </member>
        <member name="M:Inv.Dock.RemovePanel(Inv.Panel)">
            <summary>
            Remove a specific panel from the dock.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.AddHeader(Inv.Panel)">
            <summary>
            Add a header panel to the dock.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.InsertHeader(System.Int32,Inv.Panel)">
            <summary>
            Insert a header panel in the dock.
            </summary>
            <param name="Index"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.RemoveHeader(Inv.Panel)">
            <summary>
            Remove a header panel from the dock.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.HasHeader(Inv.Panel)">
            <summary>
            Ask if the panel is in the dock headers.
            </summary>
            <param name="Panel"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.GetHeaders">
            <summary>
            Enumerate the header panels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.HasHeaders">
            <summary>
            Ask if the dock has any headers.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.RemoveHeaders">
            <summary>
            Remove all headers from the dock.
            </summary>
        </member>
        <member name="M:Inv.Dock.AddClient(Inv.Panel)">
            <summary>
            Add a client panel to the dock.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.InsertClient(System.Int32,Inv.Panel)">
            <summary>
            Insert a client panel in the dock.
            </summary>
            <param name="Index"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.RemoveClient(Inv.Panel)">
            <summary>
            Remove a client panel from the dock.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.HasClient(Inv.Panel)">
            <summary>
            Ask if the dock contains a client panel.
            </summary>
            <param name="Panel"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.GetClients">
            <summary>
            Enumerate the client panels in the dock.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.HasClients">
            <summary>
            Ask if the dock has any client panels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.RemoveClients">
            <summary>
            Remove the client panels from the dock.
            </summary>
        </member>
        <member name="M:Inv.Dock.AddFooter(Inv.Panel)">
            <summary>
            Add a footer panel to the dock.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.InsertFooter(System.Int32,Inv.Panel)">
            <summary>
            Insert a footer panel in the dock.
            </summary>
            <param name="Index"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.RemoveFooter(Inv.Panel)">
            <summary>
            Remove a footer panel from the dock.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Dock.HasFooter(Inv.Panel)">
            <summary>
            Ask if the dock has a footer panel.
            </summary>
            <param name="Panel"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.GetFooters">
            <summary>
            Enumerate the footer panels in the dock.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.HasFooters">
            <summary>
            Ask if the dock has any footer panels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Dock.RemoveFooters">
            <summary>
            Remove all footer panels from the dock.
            </summary>
        </member>
        <member name="M:Inv.Dock.ComposePanels(Inv.Panel[],Inv.Panel[],Inv.Panel[])">
            <summary>
            Replace all the panels with the provided arrays.
            </summary>
            <param name="HeaderArray"></param>
            <param name="ClientArray"></param>
            <param name="FooterArray"></param>
        </member>
        <member name="T:Inv.Wrap">
            <summary>
            Wraps are for horizontal and vertical cascading layout of panels.
            Wrapped panels are arranged in the order they were added.
            </summary>
        </member>
        <member name="M:Inv.Wrap.#ctor(Inv.Orientation)">
            <summary>
            Create a new wrap.
            </summary>
            <param name="Orientation"></param>
        </member>
        <member name="M:Inv.Wrap.New(Inv.Orientation)">
            <summary>
            Create a new wrap.
            </summary>
            <param name="Orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Wrap.NewVertical">
            <summary>
            Create a new vertical wrap.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Wrap.NewHorizontal">
            <summary>
            Create a new horizontal wrap.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Wrap.Orientation">
            <summary>
            Orientation of the wrapped panels.
            </summary>
        </member>
        <member name="P:Inv.Wrap.IsHorizontal">
            <summary>
            Ask if the panels are wrapped horizontally.
            </summary>
        </member>
        <member name="P:Inv.Wrap.IsVertical">
            <summary>
            Ask if the panels are wrapped vertically.
            </summary>
        </member>
        <member name="P:Inv.Wrap.PanelCount">
            <summary>
            Number of panels in the wrap.
            </summary>
        </member>
        <member name="M:Inv.Wrap.SetHorizontal">
            <summary>
            Change the wrapped panels to a horizontal orientation.
            </summary>
        </member>
        <member name="M:Inv.Wrap.SetVertical">
            <summary>
            Change the wrapped panels to a vertical orientation.
            </summary>
        </member>
        <member name="M:Inv.Wrap.SetOrientation(Inv.Orientation)">
            <summary>
            Set the orientation of the wrapped panels.
            </summary>
            <param name="Orientation"></param>
        </member>
        <member name="M:Inv.Wrap.AddPanel(Inv.Panel)">
            <summary>
            Add a panel to the end of the Wrap.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Wrap.InsertPanel(System.Int32,Inv.Panel)">
            <summary>
            Insert a panel at a specified location in the Wrap.
            </summary>
            <param name="Index"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Wrap.RemovePanels">
            <summary>
            Remove all the panels from the Wrap.
            </summary>
        </member>
        <member name="M:Inv.Wrap.RemovePanel(Inv.Panel)">
            <summary>
            Remove a specific panel from the Wrap.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Wrap.InsertPanelBefore(Inv.Panel,Inv.Panel)">
            <summary>
            Insert a panel before another panel in the Wrap.
            </summary>
            <param name="Before"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Wrap.InsertPanelAfter(Inv.Panel,Inv.Panel)">
            <summary>
            Insert a panel after another panel in the Wrap.
            </summary>
            <param name="After"></param>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Wrap.HasPanel(Inv.Panel)">
            <summary>
            Ask if the Wrap contains a panel.
            </summary>
            <param name="Panel"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Wrap.HasPanels">
            <summary>
            Ask if the Wrap contains any panels.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Wrap.GetPanels">
            <summary>
            Enumerate the panels in the Wrap (in wrapped order).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Wrap.ComposePanels(Inv.Panel[])">
            <summary>
            Replace all the panels with the provided panel array.
            </summary>
            <param name="PanelArray"></param>
        </member>
        <member name="T:Inv.Scroll">
            <summary>
            Scrolls are vertical or horizontal scrolling regions when the panels exceed the layout space.
            The native scrolling control is used for each platform and gives the expected bounce and feel.
            </summary>
        </member>
        <member name="M:Inv.Scroll.#ctor(Inv.Orientation)">
            <summary>
            Create a new scroll.
            </summary>
            <param name="Orientation"></param>
        </member>
        <member name="M:Inv.Scroll.New(Inv.Orientation)">
            <summary>
            Create a new scroll.
            </summary>
            <param name="Orientation"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Scroll.NewVertical">
            <summary>
            Create a new vertical scroll.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Scroll.NewHorizontal">
            <summary>
            Create a new horizontal scroll.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Scroll.Orientation">
            <summary>
            Orientation of the scrolled content.
            </summary>
        </member>
        <member name="P:Inv.Scroll.IsHorizontal">
            <summary>
            Ask if the content is scrolled horizontally.
            </summary>
        </member>
        <member name="P:Inv.Scroll.IsVertical">
            <summary>
            Ask if the content is scrolled vertically.
            </summary>
        </member>
        <member name="P:Inv.Scroll.Content">
            <summary>
            The content that can be scrolled.
            </summary>
        </member>
        <member name="M:Inv.Scroll.SetHorizontal">
            <summary>
            Change the scrolled content to a horizontal orientation.
            </summary>
        </member>
        <member name="M:Inv.Scroll.SetVertical">
            <summary>
            Change the scrolled content to a vertical orientation.
            </summary>
        </member>
        <member name="M:Inv.Scroll.SetOrientation(Inv.Orientation)">
            <summary>
            Set the orientation of the scrolled content.
            </summary>
            <param name="Orientation"></param>
        </member>
        <member name="T:Inv.Board">
            <summary>
            The board is for pinning panels in any location and permits overlapping panels.
            Z-order is determined by the order the panels are added to the board.
            </summary>
        </member>
        <member name="M:Inv.Board.#ctor">
            <summary>
            Create a new board.
            </summary>
        </member>
        <member name="M:Inv.Board.New">
            <summary>
            Create a new board.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Board.AddPin(Inv.Panel,Inv.Rect)">
            <summary>
            Pin the panel at a rectangular position on the board.
            </summary>
            <param name="Panel"></param>
            <param name="Rect"></param>
        </member>
        <member name="M:Inv.Board.MovePin(Inv.Panel,Inv.Rect)">
            <summary>
            Move a pinned panel to a new rectangular position on the board.
            </summary>
            <param name="Panel"></param>
            <param name="Rect"></param>
        </member>
        <member name="M:Inv.Board.RemovePin(Inv.Panel)">
            <summary>
            Remove a pinned panel from the board.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Board.RemovePins">
            <summary>
            Remove all pins from the board.
            </summary>
        </member>
        <member name="M:Inv.Board.HasPanel(Inv.Panel)">
            <summary>
            Ask if the board contains a panel.
            </summary>
            <param name="Panel"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Board.GetPins">
            <summary>
            Get the panels that are pinned to this board.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.BoardPin">
            <summary>
            Panels pinned to a board.
            </summary>
        </member>
        <member name="F:Inv.BoardPin.Rect">
            <summary>
            Where the panel is pinned.
            </summary>
        </member>
        <member name="F:Inv.BoardPin.Panel">
            <summary>
            The panel which is pinned.
            </summary>
        </member>
        <member name="T:Inv.Browser">
            <summary>
            The browser embeds the native web browser for each platform.
            This is used for integrating with webapps and loading html text.
            </summary>
        </member>
        <member name="M:Inv.Browser.#ctor">
            <summary>
            Create new browser.
            </summary>
        </member>
        <member name="M:Inv.Browser.New">
            <summary>
            Create new browser.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Browser.Uri">
            <summary>
            The Uri of the currently loaded web page.
            </summary>
        </member>
        <member name="P:Inv.Browser.Html">
            <summary>
            The Html of the currently loaded web document.
            </summary>
        </member>
        <member name="E:Inv.Browser.FetchEvent">
            <summary>
            Fired before any Uri is fetched from the web server. Can be used to cancel the fetch.
            </summary>
        </member>
        <member name="E:Inv.Browser.ReadyEvent">
            <summary>
            Fired after each Uri is completely loaded and ready for the end user.
            </summary>
        </member>
        <member name="M:Inv.Browser.LoadUri(System.Uri)">
            <summary>
            Load the web page at the provided <paramref name="Uri"/>.
            </summary>
            <param name="Uri"></param>
        </member>
        <member name="M:Inv.Browser.LoadBinary(Inv.Binary)">
            <summary>
            Load a web page from the provided <paramref name="Binary"/> document.
            </summary>
            <param name="Binary"></param>
        </member>
        <member name="M:Inv.Browser.LoadHtml(System.String)">
            <summary>
            Load a web page from the provided <paramref name="Html"/> document.
            </summary>
            <param name="Html"></param>
        </member>
        <member name="T:Inv.BrowserFetch">
            <summary>
            The browser is proposing to fetch the given uri.
            You can optionally cancel the fetch.
            </summary>
        </member>
        <member name="P:Inv.BrowserFetch.Uri">
            <summary>
            Uri that will be fetched.
            </summary>
        </member>
        <member name="M:Inv.BrowserFetch.Cancel">
            <summary>
            Prevent the fetch.
            </summary>
        </member>
        <member name="T:Inv.BrowserReady">
            <summary>
            The browser has loaded the given uri.
            </summary>
        </member>
        <member name="P:Inv.BrowserReady.Uri">
            <summary>
            Uri that has been fetched.
            </summary>
        </member>
        <member name="T:Inv.Zoom">
            <summary>
            Pinch-or-zoom gesture.
            </summary>
        </member>
        <member name="P:Inv.Zoom.Point">
            <summary>
            Centre point of the zoom gesture.
            </summary>
        </member>
        <member name="P:Inv.Zoom.Delta">
            <summary>
            -1 for reduce and +1 for expand
            </summary>
        </member>
        <member name="T:Inv.Canvas">
            <summary>
            Canvas is for custom drawing using primitives (lines, rectangles, ellipses, text and images).
            </summary>
        </member>
        <member name="M:Inv.Canvas.#ctor">
            <summary>
            Create a new canvas.
            </summary>
        </member>
        <member name="M:Inv.Canvas.New">
            <summary>
            Create a new canvas.
            </summary>
            <returns></returns>
        </member>
        <member name="E:Inv.Canvas.MeasureEvent">
            <summary>
            Handle this event to specify the measured dimensions of the canvas.
            </summary>
        </member>
        <member name="P:Inv.Canvas.HasMeasure">
            <summary>
            Ask if the <see cref="E:Inv.Canvas.MeasureEvent"/> is handled.
            </summary>
        </member>
        <member name="E:Inv.Canvas.DrawEvent">
            <summary>
            Handle this event to draw the entire canvas from scratch.
            </summary>
        </member>
        <member name="E:Inv.Canvas.SingleTapEvent">
            <summary>
            Fired when the user completes a single tap on the canvas.
            </summary>
        </member>
        <member name="E:Inv.Canvas.DoubleTapEvent">
            <summary>
            Fired when the user completes a double tap on the canvas.
            </summary>
        </member>
        <member name="E:Inv.Canvas.ContextTapEvent">
            <summary>
            Fired when the user completes a context tap (right mouse click or long press gesture) on the canvas.
            </summary>
        </member>
        <member name="E:Inv.Canvas.PressEvent">
            <summary>
            Fired when the user starts a touch on the canvas.
            </summary>
        </member>
        <member name="E:Inv.Canvas.ReleaseEvent">
            <summary>
            Fired when the user releases their touch on the canvas.
            </summary>
        </member>
        <member name="E:Inv.Canvas.MoveEvent">
            <summary>
            Fired when the user moves their input while maintaining a touch on the canvas.
            </summary>
        </member>
        <member name="E:Inv.Canvas.ZoomEvent">
            <summary>
            Fired when the user gestures to pinch-or-zoom (includes touch gestures and mouse wheel).
            </summary>
        </member>
        <member name="E:Inv.Canvas.QueryEvent">
            <summary>
            Handle this event to publish custom regions as accessibility elements (for VoiceOver, etc).
            </summary>
        </member>
        <member name="M:Inv.Canvas.Draw">
            <summary>
            Request the canvas to draw (which fires the <see cref="E:Inv.Canvas.DrawEvent"/>)
            </summary>
        </member>
        <member name="M:Inv.Canvas.SingleTap(Inv.Point)">
            <summary>
            Programmatically invoke a single tap.
            </summary>
            <param name="Point"></param>
        </member>
        <member name="M:Inv.Canvas.DoubleTap(Inv.Point)">
            <summary>
            Programmatically invoke a double tap.
            </summary>
            <param name="Point"></param>
        </member>
        <member name="M:Inv.Canvas.ContextTap(Inv.Point)">
            <summary>
            Programmatically invoke a context tap.
            </summary>
            <param name="Point"></param>
        </member>
        <member name="M:Inv.Canvas.Press(Inv.Point)">
            <summary>
            Programmatically invoke a press.
            </summary>
            <param name="Point"></param>
        </member>
        <member name="M:Inv.Canvas.Release(Inv.Point)">
            <summary>
            Programmatically invoke a release.
            </summary>
            <param name="Point"></param>
        </member>
        <member name="M:Inv.Canvas.Move(Inv.Point)">
            <summary>
            Programmatically invoke a move.
            </summary>
            <param name="Point"></param>
        </member>
        <member name="M:Inv.Canvas.Zoom(Inv.Zoom)">
            <summary>
            Programmatically invoke a zoom.
            </summary>
            <param name="Zoom"></param>
        </member>
        <member name="T:Inv.CanvasMeasure">
            <summary>
            Used set the measured dimension in the Canvas MeasureEvent.
            Refer to the constraint which is the maximum dimension available.
            </summary>
        </member>
        <member name="P:Inv.CanvasMeasure.Constraint">
            <summary>
            Constraint is the maximum dimension available.
            </summary>
        </member>
        <member name="M:Inv.CanvasMeasure.Set(System.Int32,System.Int32)">
            <summary>
            Set the measured dimension of the canvas.
            </summary>
            <param name="Width"></param>
            <param name="Height"></param>
        </member>
        <member name="M:Inv.CanvasMeasure.Set(Inv.Dimension)">
            <summary>
            Set the measured dimension of the canvas.
            </summary>
            <param name="Dimension"></param>
        </member>
        <member name="T:Inv.CanvasQuery">
            <summary>
            Contains rectangular regions with hints that are published as accessibility elements.
            </summary>
        </member>
        <member name="M:Inv.CanvasQuery.AddRegion(Inv.Rect,System.String)">
            <summary>
            Add a hint to a rectangular region.
            </summary>
            <param name="Rect"></param>
            <param name="Hint"></param>
        </member>
        <member name="M:Inv.CanvasQuery.GetRegions">
            <summary>
            Enumerate the regions.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.CanvasRegion">
            <summary>
            The region is rectangular and has a text hint.
            </summary>
        </member>
        <member name="P:Inv.CanvasRegion.Rect">
            <summary>
            Rectangular location within the canvas.
            </summary>
        </member>
        <member name="P:Inv.CanvasRegion.Hint">
            <summary>
            The text hint to be published for accessibility.
            </summary>
        </member>
        <member name="T:Inv.VerticalPosition">
            <summary>
            Vertical positioning for drawing text on the canvas.
            </summary>
        </member>
        <member name="F:Inv.VerticalPosition.Top">
            <summary>
            The text is draw using the point as the top edge.
            </summary>
        </member>
        <member name="F:Inv.VerticalPosition.Center">
            <summary>
            The text is drawn vertically centered around the point.
            </summary>
        </member>
        <member name="F:Inv.VerticalPosition.Bottom">
            <summary>
            The text is draw using the point as the bottom edge.
            </summary>
        </member>
        <member name="T:Inv.HorizontalPosition">
            <summary>
            Horizontal positioning for drawing text on the canvas.
            </summary>
        </member>
        <member name="F:Inv.HorizontalPosition.Left">
            <summary>
            The text is drawn using the point as the left edge.
            </summary>
        </member>
        <member name="F:Inv.HorizontalPosition.Center">
            <summary>
            The text is drawn horizontally centered around the point.
            </summary>
        </member>
        <member name="F:Inv.HorizontalPosition.Right">
            <summary>
            The text is drawn using the point as the right edge.
            </summary>
        </member>
        <member name="T:Inv.Mirror">
            <summary>
            Vertical or horizontal flipping of drawn images on the canvas.
            </summary>
        </member>
        <member name="F:Inv.Mirror.Vertical">
            <summary>
            Flip the image on the Y-Axis
            </summary>
        </member>
        <member name="F:Inv.Mirror.Horizontal">
            <summary>
            Flip the image on the X-Axis.
            </summary>
        </member>
        <member name="T:Inv.LineJoin">
            <summary>
            Line joining when drawing polygons on the canvas.
            </summary>
        </member>
        <member name="F:Inv.LineJoin.Miter">
            <summary>
            Regular angular vertices.
            </summary>
        </member>
        <member name="F:Inv.LineJoin.Bevel">
            <summary>
            Beveled vertices.
            </summary>
        </member>
        <member name="F:Inv.LineJoin.Round">
            <summary>
            Rounded vertices.
            </summary>
        </member>
        <member name="T:Inv.DrawContract">
            <summary>
            The canvas contract for custom drawing that is supported on all platforms.
            </summary>
        </member>
        <member name="M:Inv.DrawContract.DrawText(System.String,System.String,System.Int32,Inv.FontWeight,Inv.Colour,Inv.Point,Inv.HorizontalPosition,Inv.VerticalPosition)">
            <summary>
            Draw text on the canvas.
            </summary>
            <param name="TextFragment">The text to draw</param>
            <param name="TextFontName">Optional font name</param>
            <param name="TextFontSize">Size of the text</param>
            <param name="TextFontWeight">Weight of the text</param>
            <param name="TextFontColour">Colour of the text</param>
            <param name="TextPoint">Position of the text relative to the positioning</param>
            <param name="TextHorizontal">Horizontal positioning of the text</param>
            <param name="TextVertical">Vertical positioning of the text</param>
        </member>
        <member name="M:Inv.DrawContract.DrawLine(Inv.Colour,System.Int32,Inv.Point,Inv.Point,Inv.Point[])">
            <summary>
            Draw one or more connected line segments.
            </summary>
            <param name="LineStrokeColour">The colour of the drawn lines</param>
            <param name="LineStrokeThickness">Thickness of the drawn lines</param>
            <param name="LineSourcePoint">Starting point of the first line</param>
            <param name="LineTargetPoint">Ending point of the first line</param>
            <param name="LineExtraPointArray">The extra point joins from the end of the first line and so on</param>
        </member>
        <member name="M:Inv.DrawContract.DrawRectangle(Inv.Colour,Inv.Colour,System.Int32,Inv.Rect)">
            <summary>
            Draw a rectangle on the canvas.
            </summary>
            <param name="RectangleFillColour">Fill colour</param>
            <param name="RectangleStrokeColour">Stroke colour</param>
            <param name="RectangleStrokeThickness">Thickness of the stroke</param>
            <param name="RectangleRect">Position of the rectangle</param>
        </member>
        <member name="M:Inv.DrawContract.DrawArc(Inv.Colour,Inv.Colour,System.Int32,Inv.Point,Inv.Point,System.Single,System.Single)">
            <summary>
            Draw a wedge of an ellipse.
            </summary>
            <param name="ArcFillColour"></param>
            <param name="ArcStrokeColour"></param>
            <param name="ArcStrokeThickness"></param>
            <param name="ArcCenter"></param>
            <param name="ArcRadius"></param>
            <param name="ArcStartAngle">Starting angle between 0 and 360</param>
            <param name="ArcSweepAngle">Ending angle between 0 and 360</param>
        </member>
        <member name="M:Inv.DrawContract.DrawEllipse(Inv.Colour,Inv.Colour,System.Int32,Inv.Point,Inv.Point)">
            <summary>
            Draw an ellipse on the canvas.
            </summary>
            <param name="EllipseFillColour"></param>
            <param name="EllipseStrokeColour"></param>
            <param name="EllipseStrokeThickness"></param>
            <param name="EllipseCenter"></param>
            <param name="EllipseRadius"></param>
        </member>
        <member name="M:Inv.DrawContract.DrawImage(Inv.Image,Inv.Rect,System.Single,Inv.Colour,System.Nullable{Inv.Mirror},System.Single)">
            <summary>
            Draw an image on the canvas.
            </summary>
            <param name="ImageSource"></param>
            <param name="ImageRect"></param>
            <param name="ImageOpacity"></param>
            <param name="ImageTint"></param>
            <param name="ImageMirror"></param>
            <param name="ImageRotation"></param>
        </member>
        <member name="M:Inv.DrawContract.DrawPolygon(Inv.Colour,Inv.Colour,System.Int32,Inv.LineJoin,Inv.Point,Inv.Point[])">
            <summary>
            Draw a polygon on the canvas.
            </summary>
            <param name="FillColour"></param>
            <param name="StrokeColour"></param>
            <param name="StrokeThickness"></param>
            <param name="LineJoin"></param>
            <param name="StartPoint"></param>
            <param name="PointArray"></param>
        </member>
        <member name="T:Inv.Flow">
            <summary>
            The flow is a virtualised list of panels.
            It can be thought of as a combination of a vertical scroll and stack.
            </summary>
        </member>
        <member name="M:Inv.Flow.#ctor">
            <summary>
            Create a new flow.
            </summary>
        </member>
        <member name="M:Inv.Flow.New">
            <summary>
            Create a new flow.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Flow.SectionCount">
            <summary>
            Number of sections in the flow.
            </summary>
        </member>
        <member name="E:Inv.Flow.RefreshEvent">
            <summary>
            Handle to be notified when the user requested a refresh with a gesture.
            </summary>
        </member>
        <member name="M:Inv.Flow.AddSection">
            <summary>
            Add a new section to the flow.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Flow.AddBatchedSection``1(System.Int32)">
            <summary>
            Add a batched section to the flow.
            </summary>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Inv.Flow.AddPagedSection``1(System.Int32)">
            <summary>
            Add a paged section to the flow.
            </summary>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Inv.Flow.AddCachedSection``1">
            <summary>
            Add a cached section to the flow.
            </summary>
            <typeparam name="TItem"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Inv.Flow.RemoveSection(Inv.FlowSection)">
            <summary>
            Remove a section from the flow.
            </summary>
            <param name="Section"></param>
        </member>
        <member name="M:Inv.Flow.RemoveSections">
            <summary>
            Remove all sections from the flow.
            </summary>
        </member>
        <member name="M:Inv.Flow.GetSections">
            <summary>
            Enumerate the sections in the flow.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Flow.Reload">
            <summary>
            Request a non-user reload of the flow (no refresh animation).
            </summary>
        </member>
        <member name="M:Inv.Flow.Refresh">
            <summary>
            Programmatically invoke the user refresh animation and fire the <see cref="E:Inv.Flow.RefreshEvent"/>.
            </summary>
        </member>
        <member name="T:Inv.FlowRefresh">
            <summary>
            Call <see cref="M:Inv.FlowRefresh.Complete"/> when you have finished loading data for the flow.
            Allows background loading of data.
            </summary>
        </member>
        <member name="M:Inv.FlowRefresh.Complete">
            <summary>
            Call this method when you have finished loading the data for the flow.
            </summary>
        </member>
        <member name="T:Inv.FlowSection">
            <summary>
            A section or group in the flow.
            </summary>
        </member>
        <member name="P:Inv.FlowSection.ItemCount">
            <summary>
            Number of items in the section.
            </summary>
        </member>
        <member name="P:Inv.FlowSection.Header">
            <summary>
            The header panel of the section.
            </summary>
        </member>
        <member name="P:Inv.FlowSection.Footer">
            <summary>
            The footer panel of the section.
            </summary>
        </member>
        <member name="E:Inv.FlowSection.ItemQuery">
            <summary>
            Handle to return the panel by index for this section.
            </summary>
        </member>
        <member name="E:Inv.FlowSection.RecycleEvent">
            <summary>
            Handle to recycle the panel that was originally returned from ItemQuery.
            </summary>
        </member>
        <member name="M:Inv.FlowSection.SetItemCount(System.Int32)">
            <summary>
            Set the number of items in this section.
            </summary>
            <param name="ItemCount"></param>
        </member>
        <member name="M:Inv.FlowSection.SetHeader(Inv.Panel)">
            <summary>
            Set the header panel for the section.
            </summary>
            <param name="HeaderPanel"></param>
        </member>
        <member name="M:Inv.FlowSection.SetFooter(Inv.Panel)">
            <summary>
            Set the footer panel for the section.
            </summary>
            <param name="FooterPanel"></param>
        </member>
        <member name="M:Inv.FlowSection.Reload">
            <summary>
            Reload this section.
            </summary>
        </member>
        <member name="M:Inv.FlowSection.ScrollToItemAtIndex(System.Int32)">
            <summary>
            Scroll the item at the index into view.
            </summary>
            <param name="Index"></param>
        </member>
        <member name="T:Inv.BatchedSection`1">
            <summary>
            Batched sections are for virtual lists where the data is fetched in batch from a remote server.
            This is important for web and database query results.
            </summary>
            <typeparam name="TRecord"></typeparam>
        </member>
        <member name="E:Inv.BatchedSection`1.RequestEvent">
            <summary>
            Handle to return the data for a requested batch.
            </summary>
        </member>
        <member name="E:Inv.BatchedSection`1.ItemQuery">
            <summary>
            Given a batched item, return the panel.
            </summary>
        </member>
        <member name="M:Inv.BatchedSection`1.SetItemCount(System.Int32)">
            <summary>
            Set the number of items in the batched section.
            </summary>
            <param name="ItemCount"></param>
        </member>
        <member name="M:Inv.BatchedSection`1.SetHeader(Inv.Panel)">
            <summary>
            Set the header panel for the batched section.
            </summary>
            <param name="HeaderPanel"></param>
        </member>
        <member name="M:Inv.BatchedSection`1.SetFooter(Inv.Panel)">
            <summary>
            Set the footer panel for the batched section.
            </summary>
            <param name="FooterPanel"></param>
        </member>
        <member name="M:Inv.BatchedSection`1.Reload">
            <summary>
            Reload the batched section.
            </summary>
        </member>
        <member name="T:Inv.CachedSection`1">
            <summary>
            Cached sections are for virtual lists where the entire list is known.
            The caching is for reusing the tiles displayed in the viewport.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="M:Inv.CachedSection`1.Template``1(System.Func{``0},System.Action{``0,`0})">
            <summary>
            Specify how to produce a new tile and compose an item into a tile.
            </summary>
            <typeparam name="TTile"></typeparam>
            <param name="NewFunction"></param>
            <param name="ComposeAction"></param>
        </member>
        <member name="M:Inv.CachedSection`1.Clear">
            <summary>
            Clear all items from the cached section.
            </summary>
        </member>
        <member name="M:Inv.CachedSection`1.Load(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Load the 
            </summary>
            <param name="Records"></param>
        </member>
        <member name="M:Inv.CachedSection`1.Reload">
            <summary>
            Reload the cached section.
            </summary>
        </member>
        <member name="T:Inv.PagedSectionRequestDelegate`1">
            <summary>
            This delegate is used for requesting a page window of items.
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="StartIndex"></param>
            <param name="EndIndex"></param>
            <param name="ReturnAction"></param>
        </member>
        <member name="T:Inv.PagedSection`1">
            <summary>
            Paged sections are for virtual lists where the number of items is known, but not the individual items.
            
            There is also caching to reuse the tiles displayed in the viewport.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="E:Inv.PagedSection`1.RequestEvent">
            <summary>
            Handle this event to load the items for a given page window.
            </summary>
        </member>
        <member name="M:Inv.PagedSection`1.Template``1(System.Func{``0},System.Action{``0,`0})">
            <summary>
            Specify how to produce a new tile and compose an item into a tile.
            </summary>
            <typeparam name="TTile"></typeparam>
            <param name="NewFunction"></param>
            <param name="ComposeAction"></param>
        </member>
        <member name="M:Inv.PagedSection`1.Load(System.Int32)">
            <summary>
            Load a paged section given a total item count.
            </summary>
            <param name="ItemCount"></param>
        </member>
        <member name="T:Inv.Frame">
            <summary>
            The frame is simply a container for another panel and has no other layout behaviour.
            It is used to switch content inside another layout and can be animated using transitions.
            </summary>
        </member>
        <member name="M:Inv.Frame.#ctor">
            <summary>
            Create a new frame.
            </summary>
        </member>
        <member name="M:Inv.Frame.New">
            <summary>
            Create a new frame.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Frame.Content">
            <summary>
            Contained content of the frame.
            </summary>
        </member>
        <member name="M:Inv.Frame.Transition(Inv.Panel)">
            <summary>
            Transition the content to another panel.
            </summary>
            <param name="ToPanel"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.Table">
            <summary>
            This layout has rows and columns that can be sized as auto, star or fixed.
            Row and column spanning is not supported.
            </summary>
        </member>
        <member name="M:Inv.Table.#ctor">
            <summary>
            Create a new table.
            </summary>
        </member>
        <member name="M:Inv.Table.New">
            <summary>
            Create a new table.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Table.ColumnCount">
            <summary>
            Number of columns in the table.
            </summary>
        </member>
        <member name="P:Inv.Table.RowCount">
            <summary>
            Number of rows in the table.
            </summary>
        </member>
        <member name="M:Inv.Table.RemovePanel(Inv.Panel)">
            <summary>
            Remove a panel from the table rows, columns or cells.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Table.RemovePanels">
            <summary>
            Remove all panels from the table columns, rows and cells.
            </summary>
        </member>
        <member name="M:Inv.Table.AddAutoRow">
            <summary>
            Add a new auto-sized row to the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.AddStarRow(System.Int32)">
            <summary>
            Add a new star-sized row to the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.AddFixedRow(System.Int32)">
            <summary>
            Add a new fixed-sized row to the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.InsertRow(System.Int32)">
            <summary>
            Insert a row in the table.
            </summary>
            <param name="Index"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.RemoveRow(Inv.TableRow)">
            <summary>
            Remove a row from the table.
            </summary>
            <param name="Row"></param>
        </member>
        <member name="M:Inv.Table.GetRow(System.Int32)">
            <summary>
            Get a row in the table by index.
            </summary>
            <param name="Index"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.GetRows">
            <summary>
            Enumerate all rows in the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.RemoveRows">
            <summary>
            Remove all rows from the table.
            </summary>
        </member>
        <member name="M:Inv.Table.RemoveColumns">
            <summary>
            Remove all columns from the table.
            </summary>
        </member>
        <member name="M:Inv.Table.RemoveCells">
            <summary>
            Remove all cells from the table.
            </summary>
        </member>
        <member name="M:Inv.Table.AddAutoColumn">
            <summary>
            Add a new auto-sized column to the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.AddStarColumn(System.Int32)">
            <summary>
            Add a new star-sized column to the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.AddFixedColumn(System.Int32)">
            <summary>
            Add a new fixed-sized column to the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.InsertColumn(System.Int32)">
            <summary>
            Insert a column in the table.
            </summary>
            <param name="Index"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.RemoveColumn(Inv.TableColumn)">
            <summary>
            Remove a column from the table.
            </summary>
            <param name="Column"></param>
        </member>
        <member name="M:Inv.Table.GetColumn(System.Int32)">
            <summary>
            Get a column in the table by index.
            </summary>
            <param name="Index"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.GetColumns">
            <summary>
            Enumerate all columns in the table.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.GetCell(System.Int32,System.Int32)">
            <summary>
            Get a cell by the column and row index.
            </summary>
            <param name="ColumnIndex"></param>
            <param name="RowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.GetCell(Inv.TableColumn,Inv.TableRow)">
            <summary>
            Get a cell by the column and row.
            </summary>
            <param name="Column"></param>
            <param name="Row"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.GetCells">
            <summary>
            Enumerate all cells in the table (returned row-by-row).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Table.Compose(System.Int32,System.Int32)">
            <summary>
            Adjust the number of rows and columns in the table.
            </summary>
            <param name="Columns"></param>
            <param name="Rows"></param>
        </member>
        <member name="M:Inv.Table.Compose(Inv.Panel[0:,0:])">
            <summary>
            Adjust the number of rows and columns in the table and apply the panels to the cells.
            </summary>
            <param name="PanelArray"></param>
        </member>
        <member name="T:Inv.Button">
            <summary>
            This is a push-button which contains a content panel.
            </summary>
        </member>
        <member name="M:Inv.Button.#ctor(Inv.ButtonStyle)">
            <summary>
            Create a new button.
            </summary>
        </member>
        <member name="M:Inv.Button.New(Inv.ButtonStyle)">
            <summary>
            Create a new button.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Button.NewStark">
            <summary>
            Create a new stark button.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Button.NewFlat">
            <summary>
            Create a new flat button.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Button.Style">
            <summary>
            The interaction style for the button.
            </summary>
        </member>
        <member name="P:Inv.Button.Content">
            <summary>
            The content is the layout panel inside the button.
            </summary>
        </member>
        <member name="P:Inv.Button.IsEnabled">
            <summary>
            When the button is enabled for user interaction.
            </summary>
        </member>
        <member name="P:Inv.Button.IsFocusable">
            <summary>
            Button can be focused.
            </summary>
        </member>
        <member name="P:Inv.Button.Hint">
            <summary>
            Optional hint text as used in accessibility and tooltips.
            </summary>
        </member>
        <member name="P:Inv.Button.Focus">
            <summary>
            The focus manager for the button.
            </summary>
        </member>
        <member name="P:Inv.Button.Tooltip">
            <summary>
            The tooltip for the button.
            </summary>
        </member>
        <member name="P:Inv.Button.IsHovered">
            <summary>
            The user is hovered over the button and have not yet moved away.
            </summary>
        </member>
        <member name="P:Inv.Button.IsPushed">
            <summary>
            The user pressed the button and have not yet released.
            </summary>
        </member>
        <member name="E:Inv.Button.OverEvent">
            <summary>
            Over is fired when the user starts hovering over the button.
            </summary>
        </member>
        <member name="E:Inv.Button.AwayEvent">
            <summary>
            Away is fired when the user moves the hover away from the button.
            </summary>
        </member>
        <member name="E:Inv.Button.PressEvent">
            <summary>
            Press is fired when the user presses on the button.
            </summary>
        </member>
        <member name="E:Inv.Button.ReleaseEvent">
            <summary>
            Release is fired when the user releases a pressed button.
            </summary>
        </member>
        <member name="E:Inv.Button.SingleTapEvent">
            <summary>
            Single tap is a short press on a touch screen or a left mouse click.
            </summary>
        </member>
        <member name="E:Inv.Button.ContextTapEvent">
            <summary>
            Context tap is a long press on a touch screen or a right mouse click.
            </summary>
        </member>
        <member name="M:Inv.Button.SingleTap">
            <summary>
            Programmatically invoke the single tap.
            </summary>
        </member>
        <member name="M:Inv.Button.HasSingleTap">
            <summary>
            Ask if the single tap event has been handled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Button.RemoveSingleTap">
            <summary>
            Remove the single tap event if it has been set.
            </summary>
        </member>
        <member name="M:Inv.Button.ContextTap">
            <summary>
            Programmatically invoke the context tap.
            </summary>
        </member>
        <member name="M:Inv.Button.HasContextTap">
            <summary>
            Ask if the context tap event has been handled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Button.RemoveContextTap">
            <summary>
            Remove the single tap event if it has been set.
            </summary>
        </member>
        <member name="M:Inv.Button.Press">
            <summary>
            Programmatically invoke the button press.
            </summary>
        </member>
        <member name="M:Inv.Button.HasPress">
            <summary>
            Ask if the press event has been handled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Button.Release">
            <summary>
            Programmatically invoke the button release.
            </summary>
        </member>
        <member name="M:Inv.Button.HasRelease">
            <summary>
            Ask if the release event has been handled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Button.Over">
            <summary>
            Programmatically invoke the button hover over.
            </summary>
        </member>
        <member name="M:Inv.Button.HasOver">
            <summary>
            Ask if the Over event has been handled.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Button.Away">
            <summary>
            Programmatically invoke the button hover away.
            </summary>
        </member>
        <member name="M:Inv.Button.HasAway">
            <summary>
            Ask if the away event has been handled.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.ButtonStyle">
            <summary>
            The behaviour style for a button.
            </summary>
        </member>
        <member name="F:Inv.ButtonStyle.Stark">
            <summary>
            Stark buttons have no automatic styling when hovered, pushed or disabled.
            </summary>
        </member>
        <member name="F:Inv.ButtonStyle.Flat">
            <summary>
            Flat buttons have automatic styling when hovered, pushed and disabled.
            When hovered, background colour is lightened by 25%.
            When pushed, background colour is darkened by 25%.
            When disabled, the opacity is halved (ie. 50%).
            </summary>
        </member>
        <member name="T:Inv.Label">
            <summary>
            Labels are plain-text blocks that can be styled with a font.
            </summary>
        </member>
        <member name="M:Inv.Label.#ctor">
            <summary>
            Create a new label.
            </summary>
        </member>
        <member name="M:Inv.Label.New">
            <summary>
            Create a new label.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Label.Font">
            <summary>
            The font used to draw the text.
            </summary>
        </member>
        <member name="P:Inv.Label.Justify">
            <summary>
            Text justification.
            </summary>
        </member>
        <member name="P:Inv.Label.Text">
            <summary>
            The text to display in the label. Supports unicode and Environment.NewLine characters.
            </summary>
        </member>
        <member name="P:Inv.Label.LineWrapping">
            <summary>
            Whether the text will wrap to over new lines if there is not enough space, or truncate with an ellipsis.
            </summary>
        </member>
        <member name="T:Inv.Graphic">
            <summary>
            Display an image such as PNG. The image is uniformly scaled to fit the layout.
            </summary>
        </member>
        <member name="M:Inv.Graphic.#ctor">
            <summary>
            Create a new graphic.
            </summary>
        </member>
        <member name="M:Inv.Graphic.New">
            <summary>
            Create a new graphic.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Graphic.Image">
            <summary>
            The image displayed with uniform stretching to fit the available size.
            </summary>
        </member>
        <member name="T:Inv.EditInput">
            <summary>
            The edit modes for the <see cref="T:Inv.Edit"/>
            </summary>
        </member>
        <member name="F:Inv.EditInput.Decimal">
            <summary>
            Decimal number
            </summary>
        </member>
        <member name="F:Inv.EditInput.Email">
            <summary>
            Email address
            </summary>
        </member>
        <member name="F:Inv.EditInput.Integer">
            <summary>
            Integer number
            </summary>
        </member>
        <member name="F:Inv.EditInput.Name">
            <summary>
            Name of person, place or thing
            </summary>
        </member>
        <member name="F:Inv.EditInput.Number">
            <summary>
            General number
            </summary>
        </member>
        <member name="F:Inv.EditInput.Password">
            <summary>
            Password
            </summary>
        </member>
        <member name="F:Inv.EditInput.Phone">
            <summary>
            Phone number
            </summary>
        </member>
        <member name="F:Inv.EditInput.Search">
            <summary>
            Search terms
            </summary>
        </member>
        <member name="F:Inv.EditInput.Text">
            <summary>
            General text
            </summary>
        </member>
        <member name="F:Inv.EditInput.Uri">
            <summary>
            Web Uri
            </summary>
        </member>
        <member name="F:Inv.EditInput.Username">
            <summary>
            Username
            </summary>
        </member>
        <member name="T:Inv.Edit">
            <summary>
            Single-line text editor with several input modes.
            </summary>
        </member>
        <member name="M:Inv.Edit.#ctor(Inv.EditInput)">
            <summary>
            Create a new edit.
            </summary>
            <param name="Input"></param>
        </member>
        <member name="M:Inv.Edit.New(Inv.EditInput)">
            <summary>
            Create a new edit.
            </summary>
            <param name="Input"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Edit.NewText">
            <summary>
            Create a new Text <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewNumber">
            <summary>
            Create a new Number <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewInteger">
            <summary>
            Create a new Integer <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewDecimal">
            <summary>
            Create a new Decimal <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewName">
            <summary>
            Create a new Name <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewEmail">
            <summary>
            Create a new Email <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewPhone">
            <summary>
            Create a new Phone <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewPassword">
            <summary>
            Create a new Password <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewSearch">
            <summary>
            Create a new Search <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewUri">
            <summary>
            Create a new Uri <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="M:Inv.Edit.NewUsername">
            <summary>
            Create a new Username <see cref="T:Inv.Edit" />
            </summary>
        </member>
        <member name="P:Inv.Edit.Input">
            <summary>
            The input mode.
            </summary>
        </member>
        <member name="P:Inv.Edit.Focus">
            <summary>
            The focus manager for the edit.
            </summary>
        </member>
        <member name="P:Inv.Edit.Font">
            <summary>
            The font used to display the text.
            </summary>
        </member>
        <member name="P:Inv.Edit.Justify">
            <summary>
            Text justification.
            </summary>
        </member>
        <member name="P:Inv.Edit.IsReadOnly">
            <summary>
            When readonly, the edit cannot be changed by the user.
            </summary>
        </member>
        <member name="P:Inv.Edit.Text">
            <summary>
            The text in the edit box.
            </summary>
        </member>
        <member name="E:Inv.Edit.ChangeEvent">
            <summary>
            Handle to be notified when the edit text is changed.
            </summary>
        </member>
        <member name="P:Inv.Edit.HasChange">
            <summary>
            Ask if the <see cref="E:Inv.Edit.ChangeEvent"/> is handled.
            </summary>
        </member>
        <member name="E:Inv.Edit.ReturnEvent">
            <summary>
            Handle to be notified when the edit text is accepted (enter key, or soft keyboard return).
            </summary>
        </member>
        <member name="P:Inv.Edit.HasReturn">
            <summary>
            Ask if the <see cref="E:Inv.Edit.ReturnEvent"/> is handled.
            </summary>
        </member>
        <member name="M:Inv.Edit.Return">
            <summary>
            Programmatically invoke the return.
            </summary>
        </member>
        <member name="T:Inv.Memo">
            <summary>
            Multi-line text editor with optional markup.
            </summary>
        </member>
        <member name="M:Inv.Memo.#ctor">
            <summary>
            Create a new memo.
            </summary>
        </member>
        <member name="M:Inv.Memo.New">
            <summary>
            Create a new memo.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Memo.Focus">
            <summary>
            The focus manager for the memo.
            </summary>
        </member>
        <member name="P:Inv.Memo.Font">
            <summary>
            Font of the text in the memo.
            </summary>
        </member>
        <member name="P:Inv.Memo.Text">
            <summary>
            Text in the memo.
            </summary>
        </member>
        <member name="P:Inv.Memo.IsReadOnly">
            <summary>
            Whether the user can change the memo.
            </summary>
        </member>
        <member name="E:Inv.Memo.ChangeEvent">
            <summary>
            Handle to be notified when the memo text is changed.
            </summary>
        </member>
        <member name="P:Inv.Memo.HasChange">
            <summary>
            Ask if the memo handles the <see cref="E:Inv.Memo.ChangeEvent"/>.
            </summary>
        </member>
        <member name="M:Inv.Memo.RemoveMarkups">
            <summary>
            Remove all markups from the memo.
            </summary>
        </member>
        <member name="M:Inv.Memo.RemoveMarkup(Inv.MemoMarkup)">
            <summary>
            Remove a markup from the memo.
            </summary>
            <param name="Markup"></param>
        </member>
        <member name="M:Inv.Memo.AddMarkup">
            <summary>
            Add a new markup to the memo.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.MemoMarkup">
            <summary>
            Markup allows rich text selections in a memo.
            </summary>
        </member>
        <member name="P:Inv.MemoMarkup.Font">
            <summary>
            The font of this bit of markup.
            </summary>
        </member>
        <member name="M:Inv.MemoMarkup.InRange(System.Int32)">
            <summary>
            Ask if this markup covers a particular index in the memo text.
            </summary>
            <param name="Index"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.MemoMarkup.AddRange(System.Int32,System.Int32)">
            <summary>
            Apply this markup to a range in the memo text.
            </summary>
            <param name="Index"></param>
            <param name="Count"></param>
        </member>
        <member name="T:Inv.Video">
            <summary>
            Playback for video such as mp4. The video is uniformly scaled to fit the layout.
            </summary>
        </member>
        <member name="M:Inv.Video.#ctor">
            <summary>
            Create a new video.
            </summary>
        </member>
        <member name="M:Inv.Video.New">
            <summary>
            Create a new video.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Video.Uri">
            <summary>
            The Uri of the currently loaded video.
            </summary>
        </member>
        <member name="P:Inv.Video.File">
            <summary>
            The File of the currently loaded video.
            </summary>
        </member>
        <member name="P:Inv.Video.Asset">
            <summary>
            The Asset of the currently loaded video.
            </summary>
        </member>
        <member name="P:Inv.Video.IsPlaying">
            <summary>
            Is the video playing.
            </summary>
        </member>
        <member name="P:Inv.Video.IsPaused">
            <summary>
            Is the video paused.
            </summary>
        </member>
        <member name="P:Inv.Video.IsStopped">
            <summary>
            Is the video stopped.
            </summary>
        </member>
        <member name="M:Inv.Video.SetSourceAsset(Inv.Asset)">
            <summary>
            Set the video source to an asset.
            </summary>
        </member>
        <member name="M:Inv.Video.SetSourceFile(Inv.File)">
            <summary>
            Set the video source to a file.
            </summary>
        </member>
        <member name="M:Inv.Video.SetSourceUri(System.Uri)">
            <summary>
            Set the video source to a uri.
            </summary>
        </member>
        <member name="M:Inv.Video.Play">
            <summary>
            Play the video.
            </summary>
        </member>
        <member name="M:Inv.Video.Pause">
            <summary>
            Pause the playing video.
            </summary>
        </member>
        <member name="M:Inv.Video.Stop">
            <summary>
            Stop the video.
            </summary>
        </member>
        <member name="M:Inv.Video.Restart">
            <summary>
            Restart the video.
            </summary>
        </member>
        <member name="T:Inv.Switch">
            <summary>
            Switch for boolean toggle state.
            </summary>
        </member>
        <member name="M:Inv.Switch.#ctor">
            <summary>
            Create a new switch.
            </summary>
        </member>
        <member name="M:Inv.Switch.New">
            <summary>
            Create a new switch.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Switch.IsOn">
            <summary>
            State of the switch.
            </summary>
        </member>
        <member name="P:Inv.Switch.PrimaryColour">
            <summary>
            Primary colour of the switch.
            </summary>
        </member>
        <member name="P:Inv.Switch.SecondaryColour">
            <summary>
            Primary colour of the switch.
            </summary>
        </member>
        <member name="P:Inv.Switch.IsEnabled">
            <summary>
            Whether the user can change the switch.
            </summary>
        </member>
        <member name="E:Inv.Switch.ChangeEvent">
            <summary>
            Handle to be notified when the switch state is changed.
            </summary>
        </member>
        <member name="P:Inv.Switch.HasChange">
            <summary>
            Ask if the switch handles the <see cref="E:Inv.Switch.ChangeEvent"/>.
            </summary>
        </member>
        <member name="T:Inv.Block">
            <summary>
            Block of spans of formatted text.
            </summary>
        </member>
        <member name="M:Inv.Block.#ctor">
            <summary>
            Create a new block.
            </summary>
        </member>
        <member name="M:Inv.Block.New">
            <summary>
            Create a new block.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Block.Font">
            <summary>
            The font used to draw the text.
            </summary>
        </member>
        <member name="P:Inv.Block.Justify">
            <summary>
            Text justification.
            </summary>
        </member>
        <member name="P:Inv.Block.LineWrapping">
            <summary>
            Whether the text will wrap to over new lines if there is not enough space, or truncate with an ellipsis.
            </summary>
        </member>
        <member name="T:Inv.Native">
            <summary>
            Contains a native control for the platform.
            </summary>
        </member>
        <member name="M:Inv.Native.#ctor(System.Object)">
            <summary>
            Create a new native.
            </summary>
        </member>
        <member name="M:Inv.Native.New(System.Object)">
            <summary>
            Create a new native panel.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.Native.Content">
            <summary>
            The native control.
            </summary>
        </member>
        <member name="T:Inv.Panel`1">
            <summary>
            This template class should be subclassed to declare custom controls.
            The generic parameter is the type of the base panel in your custom control.
            It is a terse syntax and implements the Panel interface contract.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Inv.Panel`1.Base">
            <summary>
            In your constructor, set this Base field with the base panel of your custom control.
            </summary>
        </member>
        <member name="T:Inv.Pathing.WeightFunction">
            <summary>
            Calculates the weight for a given (X, Y).
            </summary>
            <param name="X"></param>
            <param name="Y"></param>
            <param name="CheckOnly"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.Pathing.Algorithm">
            <summary>
            A* pathing algorithm.
            </summary>
        </member>
        <member name="M:Inv.Pathing.Algorithm.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new pathing algorithm for a logical grid.
            This class is optimised and width and height must be a power of 2.
            </summary>
            <param name="GridWidth"></param>
            <param name="GridHeight"></param>
        </member>
        <member name="P:Inv.Pathing.Algorithm.GridWidth">
            <summary>
            Logical width of the grid.
            </summary>
        </member>
        <member name="P:Inv.Pathing.Algorithm.GridHeight">
            <summary>
            Logical height of the grid.
            </summary>
        </member>
        <member name="P:Inv.Pathing.Algorithm.HeuristicEstimate">
            <summary>
            Defaults to 2.
            </summary>
        </member>
        <member name="P:Inv.Pathing.Algorithm.PunishChangeDirection">
            <summary>
            Defaults to false.
            </summary>
        </member>
        <member name="P:Inv.Pathing.Algorithm.TieBreaker">
            <summary>
            Defaults to false.
            </summary>
        </member>
        <member name="P:Inv.Pathing.Algorithm.SearchLimit">
            <summary>
            Defaults to 2000.
            </summary>
        </member>
        <member name="P:Inv.Pathing.Algorithm.Formula">
            <summary>
            Defaults to Manhattan.
            </summary>
        </member>
        <member name="M:Inv.Pathing.Algorithm.FindPath(Inv.Point,Inv.Point,Inv.Pathing.WeightFunction)">
            <summary>
            Find the best path from <paramref name="start"/> to <paramref name="end"/> using the <paramref name="WeightFunction"/> to calculate weight of each logical cell.
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="WeightFunction"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Pathing.PriorityQueue`1.Push(`0)">
            <summary>
            Push an object onto the PQ
            </summary>
            <param name="Item">The new object</param>
            <returns>The index in the list where the object is _now_. This will change when objects are taken from or put onto the PQ.</returns>
        </member>
        <member name="M:Inv.Pathing.PriorityQueue`1.Pop">
            <summary>
            Get the smallest object and remove it.
            </summary>
            <returns>The smallest object</returns>
        </member>
        <member name="T:Inv.Pathing.FinderNode">
            <summary>
            Each point in the path (X, Y).
            </summary>
        </member>
        <member name="F:Inv.Pathing.FinderNode.X">
            <summary>
            Logical X location for this node.
            </summary>
        </member>
        <member name="F:Inv.Pathing.FinderNode.Y">
            <summary>
            Logical Y location for this node.
            </summary>
        </member>
        <member name="T:Inv.Phone">
            <summary>
            See <see cref="P:Inv.Application.Phone"/>
            </summary>
        </member>
        <member name="P:Inv.Phone.IsSupported">
            <summary>
            Ask if the device have phone services.
            </summary>
        </member>
        <member name="M:Inv.Phone.Dial(System.String)">
            <summary>
            Prompt to dial the phone number.
            </summary>
            <param name="Number"></param>
        </member>
        <member name="M:Inv.Phone.SMS(System.String)">
            <summary>
            Start an SMS session with the phone number.
            </summary>
            <param name="Number"></param>
        </member>
        <member name="T:Inv.Process">
            <summary>
            See <see cref="P:Inv.Application.Process"/>
            </summary>
        </member>
        <member name="P:Inv.Process.Id">
            <summary>
            Unique process Id (all platforms have this concept).
            </summary>
        </member>
        <member name="M:Inv.Process.GetMemoryUsage">
            <summary>
            Get the memory usage of this process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Process.MemoryReclamation">
            <summary>
            Request that the platform reclaims memory by releasing internal cache.
            </summary>
        </member>
        <member name="M:Inv.Process.GetAncillaryInformation">
            <summary>
            Get ancillary process information, specific to the device.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Process.IntentionalCrash">
            <summary>
            Intentionally cause the app to crash.
            This is for testing the behaviour of crash reporting such as HockeyApp.
            </summary>
        </member>
        <member name="T:Inv.Surface">
            <summary>
            The surface represents one layout perspective of the full real-estate of the device screen.
            You can transition between surfaces using the <see cref="P:Inv.Application.Window"/>.
            </summary>
        </member>
        <member name="P:Inv.Surface.Window">
            <summary>
            The owning <see cref="P:Inv.Surface.Window"/> for this surface.
            </summary>
        </member>
        <member name="P:Inv.Surface.Background">
            <summary>
            The surface has a background colour.
            </summary>
        </member>
        <member name="P:Inv.Surface.Content">
            <summary>
            Primary content of the surface.
            </summary>
        </member>
        <member name="E:Inv.Surface.GestureBackwardEvent">
            <summary>
            This event is fired when the user gestures to go back such as swiping on the left edge of the device or clicking the back button on a mouse.
            </summary>
        </member>
        <member name="P:Inv.Surface.HasGestureBackward">
            <summary>
            Ask if the <see cref="E:Inv.Surface.GestureBackwardEvent"/> is handled.
            </summary>
        </member>
        <member name="E:Inv.Surface.GestureForwardEvent">
            <summary>
            This event is fired when the user gestures to go forward such as swiping on the right edge of the device or clicking the forward button on a mouse.
            </summary>
        </member>
        <member name="P:Inv.Surface.HasGestureForward">
            <summary>
            Ask if the <see cref="E:Inv.Surface.GestureForwardEvent"/> is handled.
            </summary>
        </member>
        <member name="E:Inv.Surface.KeystrokeEvent">
            <summary>
            This event is fired when a key is pressed on a non-virtual keyboard including bluetooth keyboards attached to devices.
            </summary>
        </member>
        <member name="E:Inv.Surface.ArrangeEvent">
            <summary>
             The arrange event is fired when the form-factor of the surface changes.
             E.g. rotation of a device of resizing of a window such as split-screen in iOS.
            </summary>
        </member>
        <member name="E:Inv.Surface.ComposeEvent">
            <summary>
            The compose event is fired once per display frame.
            This means the event is called up to 60 times per second (60 FPS) or every ~16 milliseconds.
            This can be used for custom animations and game-loops.
            </summary>
        </member>
        <member name="E:Inv.Surface.EnterEvent">
            <summary>
            The entry event is fired when you transition to this surface.
            </summary>
        </member>
        <member name="E:Inv.Surface.LeaveEvent">
            <summary>
            The exit event is fired when you transition away from this surface.
            </summary>
        </member>
        <member name="M:Inv.Surface.NewAnimation">
            <summary>
            Create a new <see cref="T:Inv.Animation" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewBlock">
            <summary>
            Create a new <see cref="T:Inv.Block" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewBoard">
            <summary>
            Create a new <see cref="T:Inv.Board" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewButton(Inv.ButtonStyle)">
            <summary>
            Create a new <see cref="T:Inv.Button" /> with the provided button style.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewStarkButton">
            <summary>
            Create a new Stark <see cref="T:Inv.Button" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewFlatButton">
            <summary>
            Create a new Flat <see cref="T:Inv.Button" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewCanvas">
            <summary>
            Create a new <see cref="T:Inv.Canvas" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewDock(Inv.Orientation)">
            <summary>
            Create a new <see cref="T:Inv.Dock" /> with the provided <paramref name="Orientation"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewVerticalDock">
            <summary>
            Create a new Vertical <see cref="T:Inv.Dock" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewHorizontalDock">
            <summary>
            Create a new Horizontal <see cref="T:Inv.Dock" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewEdit(Inv.EditInput)">
            <summary>
            Create a new <see cref="T:Inv.Edit" /> with the provided <paramref name="Input"/> mode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewTextEdit">
            <summary>
            Create a new Text <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewNumberEdit">
            <summary>
            Create a new Number <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewIntegerEdit">
            <summary>
            Create a new Integer <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewDecimalEdit">
            <summary>
            Create a new Decimal <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewNameEdit">
            <summary>
            Create a new Name <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewEmailEdit">
            <summary>
            Create a new Email <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewPhoneEdit">
            <summary>
            Create a new Phone <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewPasswordEdit">
            <summary>
            Create a new Password <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewSearchEdit">
            <summary>
            Create a new Search <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewUriEdit">
            <summary>
            Create a new Uri <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewUsernameEdit">
            <summary>
            Create a new Username <see cref="T:Inv.Edit" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewGraphic">
            <summary>
            Create a new <see cref="T:Inv.Graphic" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewLabel">
            <summary>
            Create a new <see cref="T:Inv.Label" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewMemo">
            <summary>
            Create a new <see cref="T:Inv.Memo" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewOverlay">
            <summary>
            Create a new <see cref="T:Inv.Overlay" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewBrowser">
            <summary>
            Create a new <see cref="T:Inv.Browser" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewScroll(Inv.Orientation)">
            <summary>
            Create a new <see cref="T:Inv.Scroll" /> with the provided <paramref name="Orientation"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewVerticalScroll">
            <summary>
            Create a new Vertical <see cref="T:Inv.Scroll" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewHorizontalScroll">
            <summary>
            Create a new Horizontal <see cref="T:Inv.Scroll" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewFrame">
            <summary>
            Create a new <see cref="T:Inv.Frame" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewNative(System.Object)">
            <summary>
            Create a new <see cref="T:Inv.Native" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewStack(Inv.Orientation)">
            <summary>
            Create a new <see cref="T:Inv.Stack" /> with the provided <paramref name="Orientation"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewHorizontalStack">
            <summary>
            Create a new Horizontal <see cref="T:Inv.Stack" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewVerticalStack">
            <summary>
            Create a new Vertical <see cref="T:Inv.Stack" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewSwitch">
            <summary>
            Create a new <see cref="T:Inv.Switch" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewTable">
            <summary>
            Create a new <see cref="T:Inv.Table" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewFlow">
            <summary>
            Create a new <see cref="T:Inv.Flow" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewVideo">
            <summary>
            Create a new <see cref="T:Inv.Video" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewWrap(Inv.Orientation)">
            <summary>
            Create a new <see cref="T:Inv.Wrap" /> with the provided <paramref name="Orientation"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewHorizontalWrap">
            <summary>
            Create a new Horizontal <see cref="T:Inv.Wrap" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.NewVerticalWrap">
            <summary>
            Create a new Vertical <see cref="T:Inv.Wrap" />
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.GestureBackward">
            <summary>
            Programmatically invoke the gesture backward.
            </summary>
        </member>
        <member name="M:Inv.Surface.GestureForward">
            <summary>
            Programmatically invoke the gesture forward.
            </summary>
        </member>
        <member name="M:Inv.Surface.Keystroke(Inv.Keystroke)">
            <summary>
            Programmatically invoke a keystroke.
            </summary>
        </member>
        <member name="M:Inv.Surface.GetPanelCount">
            <summary>
            Query the number of panels connected to this surface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.GetPanelDepth">
            <summary>
            Query the maximum panel depth for panels connected to this surface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.GetPanelDisplay">
            <summary>
            Query a text visualisation of the panel tree connected to this surface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Surface.Rearrange">
            <summary>
            Programmatically invoke the arrange.
            </summary>
        </member>
        <member name="T:Inv.Vault">
            <summary>
            See <see cref="P:Inv.Application.Vault"/>.
            </summary>
        </member>
        <member name="M:Inv.Vault.NewSecret(System.String)">
            <summary>
            Create a new secret with a name.
            </summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="T:Inv.Secret">
            <summary>
            Secrets can be stored in a platform-specific secure storage such as a device key-chain.
            </summary>
        </member>
        <member name="P:Inv.Secret.Name">
            <summary>
            Name of the secret.
            </summary>
        </member>
        <member name="P:Inv.Secret.Properties">
            <summary>
            Properties attached to the secret.
            </summary>
        </member>
        <member name="M:Inv.Secret.Save">
            <summary>
            Save the secret properties to the platform-specific secure storage.
            </summary>
        </member>
        <member name="M:Inv.Secret.Load">
            <summary>
            Load the secret properties to the platform-specific secure storage.
            </summary>
        </member>
        <member name="M:Inv.Secret.Delete">
            <summary>
            Delete the secret properties to the platform-specific secure storage.
            </summary>
        </member>
        <member name="T:Inv.Application">
            <summary>
            Portable application that can be run on multiple platforms.
            </summary>
        </member>
        <member name="M:Inv.Application.#ctor">
            <summary>
            Create a new instances of a portable application.
            </summary>
        </member>
        <member name="P:Inv.Application.Title">
            <summary>
            The title is the name of the application as presented to the end user.
            </summary>
        </member>
        <member name="P:Inv.Application.IsExit">
            <summary>
            If the application has been marked to exit.
            </summary>
        </member>
        <member name="P:Inv.Application.IsSuspended">
            <summary>
            If the application is currently suspended.
            </summary>
        </member>
        <member name="P:Inv.Application.Device">
            <summary>
            Publishes device capabilities including the actual platform target.
            </summary>
        </member>
        <member name="P:Inv.Application.Process">
            <summary>
            Query the memory usage of the running process.
            </summary>
        </member>
        <member name="P:Inv.Application.Window">
            <summary>
            Represents the screen of your device and can be used to create layout surfaces.
            </summary>
        </member>
        <member name="P:Inv.Application.Directory">
            <summary>
            Working with files and folders in local storage.
            </summary>
        </member>
        <member name="P:Inv.Application.Audio">
            <summary>
            Playback of mp3 files.
            </summary>
        </member>
        <member name="P:Inv.Application.Graphics">
            <summary>
            Graphics services is for analysing images.
            </summary>
        </member>
        <member name="P:Inv.Application.Location">
            <summary>
            Reverse geocoding is the lookup of a location by a global position expressed in latitude and longitude.
            </summary>
        </member>
        <member name="P:Inv.Application.Calendar">
            <summary>
            Access the time zone for this device and invoke platform-specific pickers for date and time.
            </summary>
        </member>
        <member name="P:Inv.Application.Market">
            <summary>
            Open the app listing in the current platform's app store.
            </summary>
        </member>
        <member name="P:Inv.Application.Vault">
            <summary>
            Storage and recovery of sensitive information from the device's key-chain.
            </summary>
        </member>
        <member name="P:Inv.Application.Web">
            <summary>
            Interop with the web using RESTful APIs and Json.
            </summary>
        </member>
        <member name="P:Inv.Application.Email">
            <summary>
            Start an email message in the default mail app.
            </summary>
        </member>
        <member name="P:Inv.Application.Phone">
            <summary>
            Dial a phone number or start sending a text message.
            </summary>
        </member>
        <member name="P:Inv.Application.Clipboard">
            <summary>
            Copy and paste from the shared application clipboard.
            </summary>
        </member>
        <member name="P:Inv.Application.Haptics">
            <summary>
            Trigger haptic feedback
            </summary>
        </member>
        <member name="E:Inv.Application.StartEvent">
            <summary>
            StartEvent is guaranteed to be run the first time the app is started.
            </summary>
        </member>
        <member name="E:Inv.Application.StopEvent">
            <summary>
            StopEvent is intended to run when the app is terminated but this is not guaranteed on all platforms.
            </summary>
        </member>
        <member name="E:Inv.Application.SuspendEvent">
            <summary>
            SuspendEvent is run when the app switches from foreground to background.
            </summary>
        </member>
        <member name="E:Inv.Application.ResumeEvent">
            <summary>
            ResumeEvent is run when the app switches from background to foreground.
            </summary>
        </member>
        <member name="E:Inv.Application.ExitQuery">
            <summary>
            ExitQuery is only supported on Windows Desktop and allows you to ask for confirmation when the window is closed.
            </summary>
        </member>
        <member name="E:Inv.Application.HandleExceptionEvent">
            <summary>
            The global exception handler for the application.
            </summary>
        </member>
        <member name="M:Inv.Application.Exit">
            <summary>
            This method terminates the app on Windows but on Android/iOS it will only put the app into the background.
            </summary>
        </member>
        <member name="M:Inv.Application.RequireThreadAffinity">
            <summary>
            Check that the current thread is the main thread off the application.
            </summary>
        </member>
        <member name="M:Inv.Application.PreventThreadAffinity">
            <summary>
            Check that the current thread is not the main thread of the application.
            </summary>
        </member>
        <member name="M:Inv.Application.Access">
            <summary>
            Return the application instance for the current thread.
            </summary>
        </member>
        <member name="T:Inv.Translation.Map">
            <summary>
            Language translation map supports concepts and terms.
            </summary>
        </member>
        <member name="M:Inv.Translation.Map.#ctor">
            <summary>
            Create a new translation map.
            </summary>
        </member>
        <member name="M:Inv.Translation.Map.AddConcept(System.String)">
            <summary>
            Add a new concept.
            </summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Translation.Map.GetConcepts">
            <summary>
            Enumerate all concepts.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Translation.Map.GetConcept(System.String)">
            <summary>
            Get a concept by name.
            </summary>
            <param name="Name"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Translation.Map.Compile(System.Object)">
            <summary>
            Compile the concepts using reflection.
            </summary>
            <param name="This"></param>
        </member>
        <member name="M:Inv.Translation.Map.Clear">
            <summary>
            Remove all terms from the concepts.
            </summary>
        </member>
        <member name="M:Inv.Translation.Map.Strip">
            <summary>
            Remove all terms that does not have a translation.
            </summary>
        </member>
        <member name="M:Inv.Translation.Map.Import(System.IO.Stream)">
            <summary>
            Import term translations from a csv stream.
            </summary>
            <param name="Stream"></param>
        </member>
        <member name="M:Inv.Translation.Map.Export(System.IO.Stream)">
            <summary>
            Export term translations to a csv stream.
            </summary>
            <param name="Stream"></param>
        </member>
        <member name="M:Inv.Translation.Map.Merge(Inv.Translation.Map)">
            <summary>
            Merge this map with <paramref name="MergeMap"/>.
            </summary>
            <param name="MergeMap"></param>
        </member>
        <member name="T:Inv.Translation.Concept">
            <summary>
            Translation concept.
            </summary>
        </member>
        <member name="P:Inv.Translation.Concept.Name">
            <summary>
            Name of the translation concept.
            </summary>
        </member>
        <member name="M:Inv.Translation.Concept.Get(System.String)">
            <summary>
            Get the translated text for a term.
            </summary>
            <param name="Text">The term to lookup and will be returned if there is no translation.</param>
            <returns></returns>
        </member>
        <member name="M:Inv.Translation.Concept.Get(System.String,System.String)">
            <summary>
            Get the translated text for a term.
            </summary>
            <param name="ReferenceText">The term to lookup</param>
            <param name="OriginalText">The term to return if there is no translation</param>
            <returns></returns>
        </member>
        <member name="M:Inv.Translation.Concept.Set(System.String,System.String)">
            <summary>
            Set the translation for a term.
            </summary>
            <param name="SourceText"></param>
            <param name="TargetText"></param>
        </member>
        <member name="M:Inv.Translation.Concept.Declare``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
            <summary>
            Declare the terms based on an enumerable and delegate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Source"></param>
            <param name="Function"></param>
        </member>
        <member name="M:Inv.Translation.Concept.Define(System.Func{System.String,System.String})">
            <summary>
            Redefine the terms using a delegate.
            </summary>
            <param name="ProcessFunction"></param>
        </member>
        <member name="M:Inv.Translation.Concept.GetTerms">
            <summary>
            Get the terms.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.Web">
            <summary>
            See <see cref="P:Inv.Application.Web"/>.
            </summary>
        </member>
        <member name="M:Inv.Web.Install(System.Uri)">
            <summary>
            Install the app package located at the <paramref name="Uri"/>.
            </summary>
            <param name="Uri"></param>
        </member>
        <member name="M:Inv.Web.Launch(System.Uri)">
            <summary>
            Launch the <paramref name="Uri"/> in the default browser app.
            </summary>
            <param name="Uri"></param>
        </member>
        <member name="M:Inv.Web.NewClient(System.String,System.Int32,System.Byte[])">
            <summary>
            Create a new socket client.
            </summary>
            <param name="Host">Host name of the remote server.</param>
            <param name="Port">The listening port of the remote server.</param>
            <param name="CertHash">The thumbprint of the certificate. This can be null if you are not using SSL.</param>
            <returns></returns>
        </member>
        <member name="M:Inv.Web.NewServer(System.String,System.Int32,System.Byte[])">
            <summary>
            Create a new socket server.
            </summary>
            <param name="Host">Host name of this server.</param>
            <param name="Port">Listening port of this server.</param>
            <param name="CertHash">The thumbprint of the certificate. This can be null if you are not using SSL.</param>
            <returns></returns>
        </member>
        <member name="M:Inv.Web.NewBroker(System.Uri)">
            <summary>
            Create a web broker for interop with web sites and web services.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Inv.WebClient">
            <summary>
            Raw-socket client for implementing custom TCP protocols.
            </summary>
        </member>
        <member name="M:Inv.WebClient.Connect">
            <summary>
            Connect to the server on <see cref="P:Inv.WebClient.Host"/> and <see cref="P:Inv.WebClient.Port"/>.
            </summary>
        </member>
        <member name="M:Inv.WebClient.Disconnect">
            <summary>
            Disconnect from the server.
            </summary>
        </member>
        <member name="P:Inv.WebClient.Host">
            <summary>
            Host name.
            </summary>
        </member>
        <member name="P:Inv.WebClient.Port">
            <summary>
            Listening port.
            </summary>
        </member>
        <member name="P:Inv.WebClient.CertHash">
            <summary>
            Certificate thumbprint for SSL (otherwise should be null).
            </summary>
        </member>
        <member name="P:Inv.WebClient.InputStream">
            <summary>
            Stream for reading.
            </summary>
        </member>
        <member name="P:Inv.WebClient.OutputStream">
            <summary>
            Stream for writing.
            </summary>
        </member>
        <member name="T:Inv.WebServer">
            <summary>
            Raw-socket server for implementing custom TCP protocols.
            </summary>
        </member>
        <member name="E:Inv.WebServer.AcceptEvent">
            <summary>
            This is fired when a new client connects to the server.
            </summary>
        </member>
        <member name="E:Inv.WebServer.RejectEvent">
            <summary>
            This is fired when a client disconnects from the server.
            </summary>
        </member>
        <member name="M:Inv.WebServer.Connect">
            <summary>
            Start listening for clients on <see cref="P:Inv.WebServer.Host"/> and <see cref="P:Inv.WebServer.Port"/>.
            </summary>
        </member>
        <member name="M:Inv.WebServer.Disconnect">
            <summary>
            Stop listening for clients.
            </summary>
        </member>
        <member name="P:Inv.WebServer.Host">
            <summary>
            Host name.
            </summary>
        </member>
        <member name="P:Inv.WebServer.Port">
            <summary>
            Listening port.
            </summary>
        </member>
        <member name="P:Inv.WebServer.CertHash">
            <summary>
            Certificate thumbprint for SSL (otherwise should be null).
            </summary>
        </member>
        <member name="T:Inv.WebChannel">
            <summary>
            Represents a connected client on the server.
            </summary>
        </member>
        <member name="P:Inv.WebChannel.InputStream">
            <summary>
            Stream for reading.
            </summary>
        </member>
        <member name="P:Inv.WebChannel.OutputStream">
            <summary>
            Stream for writing.
            </summary>
        </member>
        <member name="M:Inv.WebChannel.Drop">
            <summary>
            Disconnect this client.
            </summary>
        </member>
        <member name="T:Inv.WebBroker">
            <summary>
            Broker for interop with web sites and web services.
            </summary>
        </member>
        <member name="P:Inv.WebBroker.BaseUri">
            <summary>
            Base Uri for all requests.
            </summary>
        </member>
        <member name="P:Inv.WebBroker.Headers">
            <summary>
            Additional headers to apply to the request.
            </summary>
        </member>
        <member name="T:Inv.Window">
            <summary>
            See <see cref="P:Inv.Application.Window"/>.
            </summary>
        </member>
        <member name="P:Inv.Window.Application">
            <summary>
            The owning portable application.
            </summary>
        </member>
        <member name="P:Inv.Window.Background">
            <summary>
            The background of the window.
            </summary>
        </member>
        <member name="P:Inv.Window.DefaultTransitionDuration">
            <summary>
            Default duration used in transitions on surfaces and frames.
            </summary>
        </member>
        <member name="P:Inv.Window.KeyModifier">
            <summary>
            Current state of the key modifiers shift, control and alt.
            </summary>
        </member>
        <member name="P:Inv.Window.DisplayRate">
            <summary>
            The display rate of the app in frames per second (FPS).
            </summary>
        </member>
        <member name="P:Inv.Window.Accessibility">
            <summary>
            Accessibility controls for users with special needs.
            </summary>
        </member>
        <member name="P:Inv.Window.ActiveSurface">
            <summary>
            The surface active on the screen.
            </summary>
        </member>
        <member name="P:Inv.Window.Width">
            <summary>
            The current width of the window/screen in logical points.
            This will change when the window is resized or the device is rotated.
            </summary>
        </member>
        <member name="P:Inv.Window.Height">
            <summary>
            The current height of the window/screen in logical points.
            This will change when the window is resized or the device is rotated.
            </summary>
        </member>
        <member name="P:Inv.Window.InputPrevented">
            <summary>
            Input is currently prevented to the all the panels on the window.
            </summary>
        </member>
        <member name="E:Inv.Window.KeyModifierEvent">
            <summary>
            This event is fired when a key modifier is changed (shift, control or alt).
            </summary>
        </member>
        <member name="M:Inv.Window.IsActiveSurface(Inv.Surface)">
            <summary>
            Ask if the surface is the active surface.
            </summary>
            <param name="Surface"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Window.NewSurface">
            <summary>
            Create a new surface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Window.Transition(Inv.Surface)">
            <summary>
            Transition to another surface.
            </summary>
            <param name="Surface"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Window.NewTimer">
            <summary>
            Create a timer on the main thread.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Window.NewThrottle">
            <summary>
            Create a timer on the main thread.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Inv.Window.NewTask(System.Action{Inv.WindowThread})">
            <summary>
            Create a new task to run on a background thread.
            </summary>
            <param name="Action"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Window.RunTask(System.Action{Inv.WindowThread})">
            <summary>
            Create and run a new task to run on a background thread.
            </summary>
            <param name="Action"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.Window.Browse(Inv.File)">
            <summary>
            Launch a file in the default application.
            </summary>
            <param name="File"></param>
        </member>
        <member name="M:Inv.Window.Share(Inv.File)">
            <summary>
            Share or export to another app.
            </summary>
            <param name="File"></param>
        </member>
        <member name="M:Inv.Window.Post(System.Action)">
            <summary>
            Post an action delegate to be executed at the end of the queue in the main thread.
            </summary>
            <param name="Action"></param>
        </member>
        <member name="M:Inv.Window.Call(System.Action)">
            <summary>
            Post the action delegate in the main thread and wait until it has been executed.
            If you are already in the main thread, the action delegate will simply be invoked.
            </summary>
            <param name="Action"></param>
        </member>
        <member name="M:Inv.Window.Sleep(System.TimeSpan)">
            <summary>
            Sleep the main thread for a duration.
            </summary>
            <param name="Duration"></param>
        </member>
        <member name="M:Inv.Window.SetFocus(Inv.Panel)">
            <summary>
            Set the logical focus to a specified panel.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="M:Inv.Window.PreventInput">
            <summary>
            Disable all user interaction (touch, mouse, keyboard, etc) with the panels on this surface.
            </summary>
        </member>
        <member name="M:Inv.Window.AllowInput">
            <summary>
            Re-enable all user interaction (touch, mouse, keyboard, etc) with the panels on this surface.
            </summary>
        </member>
        <member name="P:Inv.Window.NativePanelType">
            <summary>
            Base type of a native panel in the executing platform.
            </summary>
        </member>
        <member name="T:Inv.WindowAccessibility">
            <summary>
            See <see cref="P:Inv.Window.Accessibility"/>
            </summary>
        </member>
        <member name="M:Inv.WindowAccessibility.Announce(System.String)">
            <summary>
            Speak the provided text.
            </summary>
            <param name="Text"></param>
        </member>
        <member name="M:Inv.WindowAccessibility.SetFocus(Inv.Panel)">
            <summary>
            Move the accessibility focus to a specific panel.
            </summary>
            <param name="Panel"></param>
        </member>
        <member name="T:Inv.WindowDisplayRate">
            <summary>
            See <see cref="P:Inv.Window.DisplayRate"/>
            </summary>
        </member>
        <member name="P:Inv.WindowDisplayRate.PerSecond">
            <summary>
            Number of frames per second are being rendered.
            </summary>
        </member>
        <member name="T:Inv.WindowTask">
            <summary>
            Task that was launched from the window but runs in a background thread.
            </summary>
        </member>
        <member name="M:Inv.WindowTask.New(System.Action{Inv.WindowThread})">
            <summary>
            New window task.
            </summary>
            <param name="Action"></param>
            <returns></returns>
        </member>
        <member name="M:Inv.WindowTask.Run(System.Action{Inv.WindowThread})">
            <summary>
            Run in a window task.
            </summary>
            <param name="Action"></param>
            <returns></returns>
        </member>
        <member name="P:Inv.WindowTask.Elapsed">
            <summary>
            The elapsed time of the task since it was first run.
            </summary>
        </member>
        <member name="P:Inv.WindowTask.IsCompleted">
            <summary>
            Ask if the task has completed.
            </summary>
        </member>
        <member name="M:Inv.WindowTask.Run">
            <summary>
            Run the task in a background thread.
            </summary>
        </member>
        <member name="M:Inv.WindowTask.Wait">
            <summary>
            Blocking wait for the task to complete.
            </summary>
        </member>
        <member name="M:Inv.WindowTask.Wait(System.TimeSpan)">
            <summary>
            Blocking wait the specified TimeSpan for the task to complete.
            </summary>
            <param name="TimeSpan"></param>
        </member>
        <member name="T:Inv.WindowThread">
            <summary>
            The background thread of a task.
            </summary>
        </member>
        <member name="M:Inv.WindowThread.Yield(System.TimeSpan)">
            <summary>
            Sleep the thread so the task will run to the minimum duration.
            If the task has exceeded the minimum duration then no sleep is performed.
            </summary>
            <param name="MinimumDuration"></param>
        </member>
        <member name="M:Inv.WindowThread.Sleep(System.TimeSpan)">
            <summary>
            Sleep the thread for the duration.
            </summary>
            <param name="Duration"></param>
        </member>
        <member name="M:Inv.WindowThread.Post(System.Action)">
            <summary>
            Post a delegate back to the main window thread.
            </summary>
            <param name="Action"></param>
        </member>
        <member name="T:Inv.WindowTimer">
            <summary>
            Timer that fires on the main thread.
            </summary>
        </member>
        <member name="M:Inv.WindowTimer.New">
            <summary>
            New window timer.
            </summary>
            <returns></returns>
        </member>
        <member name="E:Inv.WindowTimer.IntervalEvent">
            <summary>
            This event is fired each interval as specified by the <see cref="P:Inv.WindowTimer.IntervalTime"/>.
            </summary>
        </member>
        <member name="P:Inv.WindowTimer.IntervalTime">
            <summary>
            The time to wait before firing the <see cref="E:Inv.WindowTimer.IntervalEvent"/>.
            </summary>
        </member>
        <member name="P:Inv.WindowTimer.IsEnabled">
            <summary>
            Ask if the timer is started right now.
            </summary>
        </member>
        <member name="M:Inv.WindowTimer.Start">
            <summary>
            Start the timer.
            </summary>
        </member>
        <member name="M:Inv.WindowTimer.Stop">
            <summary>
            Stop the timer.
            </summary>
        </member>
        <member name="M:Inv.WindowTimer.Restart">
            <summary>
            Restart the timer and wait for a full <see cref="P:Inv.WindowTimer.IntervalTime"/> before firing the <see cref="E:Inv.WindowTimer.IntervalEvent"/>.
            </summary>
        </member>
        <member name="T:Inv.WindowThrottle">
            <summary>
            Throttles multiple event invocations within a threshold into a single call.
            </summary>
        </member>
        <member name="M:Inv.WindowThrottle.New">
            <summary>
            New window throttle.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Inv.WindowThrottle.InitialDelay">
            <summary>
            Delay the threshold time before firing the first time in a throttled series.
            </summary>
        </member>
        <member name="P:Inv.WindowThrottle.ThresholdTime">
            <summary>
            The time to wait between firing in a throttled series.
            </summary>
        </member>
        <member name="E:Inv.WindowThrottle.FireEvent">
            <summary>
            The event is fired in a throttled manner.
            </summary>
        </member>
        <member name="M:Inv.WindowThrottle.Fire">
            <summary>
            Signal the throttle to fire.
            </summary>
        </member>
        <member name="M:Inv.WindowThrottle.Suppress">
            <summary>
            Suppress any active firing.
            </summary>
        </member>
        <member name="T:Inv.Transition">
            <summary>
            Transition is used on surfaces and frames to animate the change of content.
            </summary>
        </member>
        <member name="P:Inv.Transition.Type">
            <summary>
            Type of animation used on the transition.
            </summary>
        </member>
        <member name="P:Inv.Transition.Duration">
            <summary>
            Duration of the animation.
            </summary>
        </member>
        <member name="M:Inv.Transition.SetType(Inv.TransitionType)">
            <summary>
            Set the transition by type.
            </summary>
            <param name="Type"></param>
        </member>
        <member name="M:Inv.Transition.None">
            <summary>
            No transition, immediately change the content.
            </summary>
        </member>
        <member name="M:Inv.Transition.Fade">
            <summary>
            Fade out the old content and then fade in the new content.
            </summary>
        </member>
        <member name="M:Inv.Transition.CarouselPrevious">
            <summary>
            The old content exits to the right and the new content enters from the left.
            </summary>
        </member>
        <member name="M:Inv.Transition.CarouselNext">
            <summary>
            The old content exits to the left and the new content enters from the right.
            </summary>
        </member>
        <member name="M:Inv.Transition.CarouselAscend">
            <summary>
            The old content exits to the top and the new content enters from the bottom.
            </summary>
        </member>
        <member name="M:Inv.Transition.CarouselDescend">
            <summary>
            The old content exits to the bottom and the new content enters from the top.
            </summary>
        </member>
        <member name="T:Inv.TransitionType">
            <summary>
            Enumeration of the types of content transitions.
            </summary>
        </member>
        <member name="F:Inv.TransitionType.None">
            <summary>
            no transition
            </summary>
        </member>
        <member name="F:Inv.TransitionType.Fade">
            <summary>
            fade transition
            </summary>
        </member>
        <member name="F:Inv.TransitionType.CarouselPrevious">
            <summary>
            carousel back transition
            </summary>
        </member>
        <member name="F:Inv.TransitionType.CarouselNext">
            <summary>
            carousel next transition
            </summary>
        </member>
        <member name="F:Inv.TransitionType.CarouselAscend">
            <summary>
            carousel ascend transition
            </summary>
        </member>
        <member name="F:Inv.TransitionType.CarouselDescend">
            <summary>
            carousel descend transition
            </summary>
        </member>
    </members>
</doc>
